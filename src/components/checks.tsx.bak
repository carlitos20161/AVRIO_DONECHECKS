import React, { useEffect, useState, useRef } from "react";
import {
  Box,
  Typography,
  Button,
  TextField,
  Checkbox,
  FormControlLabel,
  Paper,
  Divider,
  Snackbar,
  Alert,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  ListItemText,
  Tabs,
  Tab,
  Avatar,
  IconButton,
  Fab,
  SpeedDial,
  SpeedDialAction,
  SpeedDialIcon,
  Tooltip,
  Fade,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Popover,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from "@mui/material";
import { Add as AddIcon, Delete as DeleteIcon, Print as PrintIcon } from "@mui/icons-material";
import { PDFDocument, rgb } from 'pdf-lib';
import { db, auth } from "../firebase";
import {
  collection,
  getDocs,
  runTransaction,
  doc,
  query,
  where,
  getDoc,
  setDoc,
  updateDoc,
  orderBy,
  onSnapshot,
} from "firebase/firestore";
import { createLocalDate } from "../utils/dateUtils";

interface Company {
  id: string;
  name: string;
  logoBase64?: string;
}

interface Employee {
  id: string;
  name: string;
  payRate: number;
  payType: string;
  payTypes?: string[];
  companyId?: string | null;
  companyIds?: string[];
  clientId?: string | null;
  clientPayTypeRelationships?: Array<{
    id: string;
    clientId: string;
    clientName: string;
    payType: 'hourly' | 'perdiem';
    payRate?: string;
    active: boolean;
  }>;
  active: boolean;  
}

interface Client {
  id: string;
  name: string;
  companyIds?: string[];
  active: boolean;  
  division?: string; // Add division field
}

interface OtherPayItem {
  id: string;
  description: string;
  amount: string;
}

interface PayInput {
  hours: string;
  otHours: string;
  holidayHours: string;
  memo: string;
  checkDate?: Date | null; // Manual check date
  paymentMethods?: string[]; // Array of 'hourly' and/or 'perdiem'
  selectedRelationshipId?: string; // Selected client-pay type relationship ID (legacy - keeping for backward compatibility)
  selectedRelationshipIds?: string[]; // NEW: Array of selected relationship IDs for multiple relationships
  perdiemAmount?: string; // Separate field for per diem amount
  perdiemBreakdown?: boolean; // Whether to use breakdown or full amount
  perdiemMonday?: string;
  perdiemTuesday?: string;
  perdiemWednesday?: string;
  perdiemThursday?: string;
  perdiemFriday?: string;
  perdiemSaturday?: string;
  perdiemSunday?: string;
  otherPay?: OtherPayItem[]; // Array of other pay items with description and amount
  [key: string]: any; // Allow dynamic relationship-based fields like "relationshipId_hours", "relationshipId_perdiemAmount", etc.
}

// Helper to chunk an array into groups of size n
function chunkArray<T>(arr: T[], size: number): T[][] {
  const result: T[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}

interface BatchChecksProps {
  onChecksCreated?: () => void;
  onGoToSection: (section: string) => void;
}

// Floating menu state interface
interface FloatingMenuState {
  open: boolean;
  companyId: string | null;
  clientId: string | null;
  checkId: string | null;
  companyName: string;
  clientName: string;
}

  const BatchChecks: React.FC<BatchChecksProps> = ({ onChecksCreated, onGoToSection }) => {
  const [companies, setCompanies] = useState<Company[]>([]);
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [clients, setClients] = useState<Client[]>([]);
  const [currentUserVisibleClientIds, setCurrentUserVisibleClientIds] = useState<string[]>([]);
  const [currentUserRole, setCurrentUserRole] = useState<string>('user');
  // Load saved data from localStorage on mount
  const loadSavedData = () => {
    try {
      const savedTabData = localStorage.getItem('batchChecks_tabData');
      const savedCompanyId = localStorage.getItem('batchChecks_companyId');
      const savedClientId = localStorage.getItem('batchChecks_clientId');
      const savedDefaultDate = localStorage.getItem('batchChecks_defaultDate');
      const savedShowReviewPanel = localStorage.getItem('batchChecks_showReviewPanel');
      
      let parsedTabData: { [key: string]: any } = {};
      if (savedTabData) {
        try {
          parsedTabData = JSON.parse(savedTabData);
          
          // Convert date strings back to Date objects
          Object.keys(parsedTabData).forEach(tabId => {
            const tab: any = parsedTabData[tabId];
            if (tab && tab.inputs) {
              Object.keys(tab.inputs).forEach((empId: string) => {
                const input: any = tab.inputs[empId];
                if (input.checkDate && typeof input.checkDate === 'string') {
                  try {
                    input.checkDate = createLocalDate(input.checkDate);
                  } catch (e) {
                    // If date parsing fails, set to null
                    input.checkDate = null;
                  }
                } else if (input.checkDate === null || input.checkDate === undefined) {
                  input.checkDate = null;
                }
              });
            }
          });
        } catch (parseError) {
          console.error('Error parsing saved tabData:', parseError);
          parsedTabData = {};
        }
      }
      
      // Always return an object with all saved values, even if some are null/empty
      const result = {
        tabData: parsedTabData,
        companyId: savedCompanyId,
        clientId: savedClientId || 'multiple',
        defaultDate: savedDefaultDate || '',
        showReviewPanel: savedShowReviewPanel === 'true'
      };
      
      console.log('ðŸ“¦ [Load Saved Data] Loaded from localStorage:', {
        hasTabData: Object.keys(parsedTabData).length > 0,
        tabDataKeys: Object.keys(parsedTabData),
        companyId: savedCompanyId,
        clientId: result.clientId,
        showReviewPanel: result.showReviewPanel
      });
      
      return result;
    } catch (error) {
      console.error('Error loading saved data:', error);
      // Return empty object instead of null so we can still access properties
      return {
        tabData: {},
        companyId: null,
        clientId: 'multiple',
        defaultDate: '',
        showReviewPanel: false
      };
    }
  };

  const savedData = loadSavedData();
  
  const [selectedCompanyId, setSelectedCompanyId] = useState<string | null>(
    savedData?.companyId || null
  );
  const [selectedClientId, setSelectedClientId] = useState<string>(savedData?.clientId || 'multiple');
  // Separate state for the default check date (independent of individual employee dates)
  const [defaultCheckDate, setDefaultCheckDate] = useState<string>(savedData?.defaultDate || '');
  
  useEffect(() => {
    console.log('ðŸ” DEBUG: selectedClientId changed to:', selectedClientId);
  }, [selectedClientId]);

  // Initialize default check date with today's date if not saved
  useEffect(() => {
    if (!defaultCheckDate) {
      const today = new Date();
      const todayString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
      setDefaultCheckDate(todayString);
    }
  }, [defaultCheckDate]);
  
  // Store data per client tab to prevent loss when switching tabs
  const [tabData, setTabData] = useState<{
    [tabId: string]: {
      selectedEmployees: { [id: string]: boolean };
      inputs: { [id: string]: PayInput };
    };
  }>(savedData?.tabData || {});
  
  // Ensure tabData is restored from localStorage if it's empty but localStorage has data
  // This is a safety net in case the initial state wasn't set correctly
  useEffect(() => {
    if (Object.keys(tabData).length === 0) {
      try {
        const savedTabData = localStorage.getItem('batchChecks_tabData');
        if (savedTabData) {
          const parsed = JSON.parse(savedTabData);
          if (Object.keys(parsed).length > 0) {
            // Convert date strings back to Date objects
            Object.keys(parsed).forEach(tabId => {
              const tab: any = parsed[tabId];
              if (tab && tab.inputs) {
                Object.keys(tab.inputs).forEach((empId: string) => {
                  const input: any = tab.inputs[empId];
                  if (input.checkDate && typeof input.checkDate === 'string') {
                    try {
                      input.checkDate = createLocalDate(input.checkDate);
                    } catch (e) {
                      input.checkDate = null;
                    }
                  } else if (input.checkDate === null || input.checkDate === undefined) {
                    input.checkDate = null;
                  }
                });
              }
            });
            console.log('ðŸ”„ [TabData Restore] Restoring tabData from localStorage', {
              tabDataKeys: Object.keys(parsed)
            });
            setTabData(parsed);
          }
        }
      } catch (error) {
        console.error('Error restoring tabData from localStorage:', error);
      }
    }
  }, []); // Only run once on mount
  
  // Save to localStorage whenever tabData changes
  useEffect(() => {
    try {
      // Convert Date objects to ISO strings for serialization
      const serializableTabData: any = {};
      Object.keys(tabData).forEach(tabId => {
        const tab = tabData[tabId];
        serializableTabData[tabId] = {
          selectedEmployees: tab.selectedEmployees,
          inputs: {}
        };
        
        if (tab.inputs) {
          Object.keys(tab.inputs).forEach(empId => {
            const input = tab.inputs[empId];
            const serializableInput: any = { ...input };
            
            // Convert Date to ISO string
            if (input.checkDate instanceof Date) {
              serializableInput.checkDate = input.checkDate.toISOString().split('T')[0];
            }
            
            serializableTabData[tabId].inputs[empId] = serializableInput;
          });
        }
      });
      
      localStorage.setItem('batchChecks_tabData', JSON.stringify(serializableTabData));
    } catch (error) {
      console.error('Error saving tabData:', error);
    }
  }, [tabData]);
  
  // Save selectedCompanyId to localStorage
  useEffect(() => {
    if (selectedCompanyId) {
      localStorage.setItem('batchChecks_companyId', selectedCompanyId);
    } else {
      localStorage.removeItem('batchChecks_companyId');
    }
  }, [selectedCompanyId]);
  
  // Save selectedClientId to localStorage
  useEffect(() => {
    localStorage.setItem('batchChecks_clientId', selectedClientId);
  }, [selectedClientId]);
  
  // Save defaultCheckDate to localStorage
  useEffect(() => {
    if (defaultCheckDate) {
      localStorage.setItem('batchChecks_defaultDate', defaultCheckDate);
    }
  }, [defaultCheckDate]);

  // Clear all saved data (call this when checks are successfully created)
  const clearSavedData = () => {
    localStorage.removeItem('batchChecks_tabData');
    localStorage.removeItem('batchChecks_companyId');
    localStorage.removeItem('batchChecks_clientId');
    localStorage.removeItem('batchChecks_defaultDate');
    localStorage.removeItem('batchChecks_showReviewPanel');
    setShowReviewPanel(false); // Also close the review panel
  };

  // Add this function after your other utility functions
const mergePDFs = async (pdfBlobs: Blob[]) => {
  const mergedPdf = await PDFDocument.create();
  
  for (const pdfBlob of pdfBlobs) {
    const pdfBytes = await pdfBlob.arrayBuffer();
    const pdf = await PDFDocument.load(pdfBytes);
    const pages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
    pages.forEach((page) => mergedPdf.addPage(page));
  }
  
  return await mergedPdf.save();
};
  // Current tab's data
  const currentTabId = selectedClientId || 'multiple';
  const selectedEmployees = tabData[currentTabId]?.selectedEmployees || {};
  const inputs = tabData[currentTabId]?.inputs || {};

  // Helper functions to update tab data
  const setSelectedEmployees = (newSelectedEmployees: { [id: string]: boolean } | ((prev: { [id: string]: boolean }) => { [id: string]: boolean })) => {
    const tabId = selectedClientId || 'multiple'; // Capture current tab at function call time
    setTabData(prev => {
      const currentData = prev[tabId] || { selectedEmployees: {}, inputs: {} };
      const updatedEmployees = typeof newSelectedEmployees === 'function' 
        ? newSelectedEmployees(currentData.selectedEmployees)
        : newSelectedEmployees;
      
      return {
        ...prev,
        [tabId]: {
          ...currentData,
          selectedEmployees: updatedEmployees
        }
      };
    });
  };

  const setInputs = (newInputs: { [id: string]: PayInput } | ((prev: { [id: string]: PayInput }) => { [id: string]: PayInput })) => {
    const tabId = selectedClientId || 'multiple'; // Capture current tab at function call time
    setTabData(prev => {
      const currentData = prev[tabId] || { selectedEmployees: {}, inputs: {} };
      const updatedInputs = typeof newInputs === 'function'
        ? newInputs(currentData.inputs)
        : newInputs;
      
      return {
        ...prev,
        [tabId]: {
          ...currentData,
          inputs: updatedInputs
        }
      };
    });
  };
  const [isCreatingChecks, setIsCreatingChecks] = useState(false);
  const [showSuccessMessage, setShowSuccessMessage] = useState(false);
  {/* Floating Success Message */}
{showSuccessMessage && (
  <Box
    sx={{
      position: 'fixed',
      top: 20,
      right: 20,
      zIndex: 9999,
      backgroundColor: '#4caf50',
      color: 'white',
      padding: '16px 24px',
      borderRadius: 2,
      boxShadow: 6,
      display: 'flex',
      alignItems: 'center',
      gap: 2,
      animation: 'slideIn 0.3s ease-out',
      '@keyframes slideIn': {
        from: { transform: 'translateX(100%)', opacity: 0 },
        to: { transform: 'translateX(0)', opacity: 1 }
      }
    }}
  >
    <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
      âœ… Checks Created Successfully!
    </Typography>
    <Button
      size="small"
      onClick={() => setShowSuccessMessage(false)}
      sx={{ 
        color: 'white', 
        borderColor: 'white',
        '&:hover': { backgroundColor: 'rgba(255,255,255,0.1)' }
      }}
    >
      âœ•
    </Button>
  </Box>
)}
  const [showReviewPanel, setShowReviewPanel] = useState(savedData?.showReviewPanel || false);
  const [selectedClientTab, setSelectedClientTab] = useState<string | null>(null);
  const [selectedEmployeeTab, setSelectedEmployeeTab] = useState<string | null>(null);
  const [dropdownSelectedEmployees, setDropdownSelectedEmployees] = useState<string[]>([]);
  const [otherPayDialogOpen, setOtherPayDialogOpen] = useState<string | null>(null);
  
  // Save showReviewPanel to localStorage
  useEffect(() => {
    if (showReviewPanel) {
      localStorage.setItem('batchChecks_showReviewPanel', 'true');
    } else {
      localStorage.removeItem('batchChecks_showReviewPanel');
    }
  }, [showReviewPanel]);
  
  const [reviewData, setReviewData] = useState<Array<{
    employee: Employee;
    input: PayInput;
    calculatedAmount: number;
    hourlyTotal: number;
    perDiemTotal: number;
    clientsWorked?: string[];
    clientBreakdown?: Array<{
      clientId: string;
      clientName: string;
      companyName: string;
      division?: string;
      amount: number;
      hourlyAmount: number;
      perDiemAmount: number;
      payType: string;
      details: Array<{label: string; value: string}>;
    }>;
  }>>([]);
  const [clientSearchTerm, setClientSearchTerm] = useState<string>("");
  const [clientStatusFilter, setClientStatusFilter] = useState<'all' | 'active' | 'inactive'>('all');
  const hasRestoredReviewRef = useRef(false);
  
  // Employee search
  const [employeeSearchTerm, setEmployeeSearchTerm] = useState<string>("");
  
  // Floating menu state
  const [floatingMenu, setFloatingMenu] = useState<FloatingMenuState>({
    open: false,
    companyId: null,
    clientId: null,
    checkId: null,
    companyName: '',
    clientName: ''
  });

  // Real-time listener for user data (including visibleClientIds)
  useEffect(() => {
    const user = auth.currentUser;
    if (!user) return;

    console.log('[BatchChecks] Setting up real-time user listener');
    const userDocRef = doc(db, "users", user.uid);
    
    const unsubscribe = onSnapshot(userDocRef, (doc) => {
      if (!doc.exists()) return;
      
      const userData = doc.data();
      const role = userData.role || 'user';
      const companyIds: string[] = userData.companyIds || [];
      const visibleClientIds: string[] = userData.visibleClientIds || [];
      
      console.log('[BatchChecks] Real-time user data update:', { role, companyIds, visibleClientIds });
      setCurrentUserVisibleClientIds(visibleClientIds);
      setCurrentUserRole(role);
    });

    return () => {
      console.log('[BatchChecks] Cleaning up user listener');
      unsubscribe();
    };
  }, []);

  useEffect(() => {
    const fetchData = async () => {
      const user = auth.currentUser;
      if (!user) return;

      // Get current user data from the real-time listener
      const userDocRef = doc(db, "users", user.uid);
      const userSnap = await getDoc(userDocRef);
      if (!userSnap.exists()) return;

      const userData = userSnap.data();
      const role = userData.role || 'user';
      const companyIds: string[] = userData.companyIds || [];

      let filteredCompanies: Company[] = [];
      if (role === 'admin') {
        // Admin: fetch ALL companies
        const compSnap = await getDocs(collection(db, "companies"));
        filteredCompanies = compSnap.docs.map((doc) => ({
          id: doc.id,
          name: doc.data()?.name || "Unnamed",
          logoBase64: doc.data()?.logoBase64 || null,
        }));
        console.log("[BatchChecks] (admin) fetched companies:", filteredCompanies);
      } else {
        // Non-admin: fetch only assigned companies using where('__name__', 'in', companyIds) in chunks of 10
        console.log("[BatchChecks] user companyIds:", companyIds);
        let companyDocs: any[] = [];
        if (companyIds.length > 0) {
          const chunks = chunkArray(companyIds, 10);
          for (const chunk of chunks) {
            const q = query(collection(db, "companies"), where("__name__", "in", chunk));
            const snap = await getDocs(q);
            companyDocs.push(...snap.docs);
          }
        }
        filteredCompanies = companyDocs.map((doc) => ({
              id: doc.id,
          name: doc.data()?.name || "Unnamed",
          logoBase64: doc.data()?.logoBase64 || null,
        }));
        console.log("[BatchChecks] (user) fetched companies:", filteredCompanies);
      }
      setCompanies(filteredCompanies);

      // Fetch employees
      let empDocs = [];
      if (role === 'admin') {
      const empSnap = await getDocs(collection(db, "employees"));
        empDocs = empSnap.docs;
        console.log("[BatchChecks] (admin) fetched employees:", empDocs.map(d => ({ id: d.id, ...d.data() })));
      } else {
        const queries = companyIds.map((id) =>
          getDocs(query(collection(db, "employees"), where("companyId", "==", id)))
        );
        const results = await Promise.allSettled(queries);
        empDocs = results
          .filter((r) => r.status === "fulfilled")
          .flatMap((r) => (r as PromiseFulfilledResult<any>).value.docs);
        results
          .filter((r) => r.status === "rejected")
          .forEach((r) => console.warn("ðŸ”¥ Failed employee query:", (r as PromiseRejectedResult).reason));
        console.log("[BatchChecks] (user) fetched employees:", empDocs.map(d => ({ id: d.id, ...d.data() })));
      }
      setEmployees(empDocs.map((d) => ({ id: d.id, ...d.data() } as Employee)));

      // Fetch clients
      const clientSnap = await getDocs(collection(db, "clients"));
      const clientList: Client[] = clientSnap.docs.map((d) => ({
        id: d.id,
        name: d.data().name,
        companyIds: d.data().companyId || [], // Note: field is 'companyId' in Firestore but contains array
        active: d.data().active ?? true,
        division: d.data().division || '', // Add division field
      }));
      setClients(clientList);
      console.log("[BatchChecks] fetched clients:", clientList);
    };
  
    fetchData();
  }, []);
  
  // Get clients for the selected company
  const companyClients = selectedCompanyId 
    ? clients.filter(client => {
        // Safety check: skip undefined/null clients
        if (!client) return false;
        
        // Basic filters
        const isActive = client.active;
        const belongsToCompany = client.companyIds && client.companyIds.includes(selectedCompanyId);
        
        // Visibility filter - only apply for non-admin users
        const isVisibleToUser = currentUserRole === 'admin' || 
                               currentUserVisibleClientIds.length === 0 || 
                               currentUserVisibleClientIds.includes(client.id);
        
        console.log(`[BatchChecks] Client ${client.name} filters:`, {
          isActive,
          belongsToCompany,
          isVisibleToUser,
          visibleClientIds: currentUserVisibleClientIds,
          clientId: client.id,
          userRole: currentUserRole
        });
        
        return isActive && belongsToCompany && isVisibleToUser;
      })
    : [];

  // Log visible clients for debugging
  useEffect(() => {
    if (companyClients.length > 0) {
      console.log('[BatchChecks] Visible clients after filtering:', companyClients.filter(c => c != null).map(c => ({
        id: c.id,
        name: c.name,
        visible: true
      })));
    }
  }, [companyClients, currentUserVisibleClientIds, currentUserRole]);

  // Filter clients based on search and status
  const filteredCompanyClients = companyClients.filter(client => {
    const matchesSearch = clientSearchTerm === "" || 
      client.name.toLowerCase().includes(clientSearchTerm.toLowerCase());
    const matchesStatus = clientStatusFilter === 'all' || 
      (clientStatusFilter === 'active' && client.active) ||
      (clientStatusFilter === 'inactive' && !client.active);
    
    return matchesSearch && matchesStatus;
  });

  // Filter clients to only show those that have at least ONE active employee
  // NEW: Show ALL clients and ALL employees who work for each client (even if they work for multiple clients)
  const clientsWithActiveEmployees = filteredCompanyClients.filter(client => {
    // Check if this client has any active employees (regardless of how many relationships they have)
    const hasActiveEmployees = employees.some(emp => {
      if (!emp.active) return false; // Employee must be active
      
      // Check if employee has at least one active relationship with this client
      const hasActiveRelationshipWithThisClient = emp.clientPayTypeRelationships?.some(rel => 
        rel.clientId === client.id && rel.active
      );
      
      // Check legacy fields - only count if employee has NO relationships
      const hasLegacyClient = emp.clientId === client.id;
      const legacyEmployeeWithThisClient = hasLegacyClient && (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0);
      
      return hasActiveRelationshipWithThisClient || legacyEmployeeWithThisClient;
    });
    
    return hasActiveEmployees;
  }).sort((a, b) => {
    const divisionA = (a.division || "").toLowerCase();
    const divisionB = (b.division || "").toLowerCase();

    if (divisionA !== divisionB) {
      return divisionA.localeCompare(divisionB);
    }

    const clientNameA = (a.name || "").toLowerCase();
    const clientNameB = (b.name || "").toLowerCase();
    return clientNameA.localeCompare(clientNameB);
  }); // Sort by division (client) first, then by department name

  // Debug logging for client filtering
  useEffect(() => {
    if (employees.length > 0 && clientsWithActiveEmployees.length > 0) {
      console.log('ðŸ” [Client Filtering] Results:');
      console.log(`  - Total clients: ${filteredCompanyClients.length}`);
      console.log(`  - Clients with active employees: ${clientsWithActiveEmployees.length}`);
      console.log(`  - Clients with active employees:`, clientsWithActiveEmployees.map(c => c.name));
      
      // Log employee counts per client
      clientsWithActiveEmployees.forEach(client => {
        const employeeCount = employees.filter(emp => {
          if (!emp.active) return false;
          
          // Check if employee has any active relationship with this client
          const hasActiveRelationshipWithThisClient = emp.clientPayTypeRelationships?.some(rel => 
            rel.clientId === client.id && rel.active
          );
          
          // Check legacy fields - only count if employee has NO relationships
          const hasLegacyClient = emp.clientId === client.id;
          const legacyEmployeeWithSingleClient = hasLegacyClient && (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0);
          
          return hasActiveRelationshipWithThisClient || legacyEmployeeWithSingleClient;
        }).length;
        console.log(`    - ${client.name}: ${employeeCount} employees`);
      });
    }
  }, [employees, clientsWithActiveEmployees]);

 // Clear all tab data when company changes (but not on initial load with saved data)
  const isInitialMount = useRef(true);
  const previousCompanyIdRef = useRef<string | null>(null);
  useEffect(() => {
    // On initial mount, store the initial companyId and don't clear tabData
    if (isInitialMount.current) {
      previousCompanyIdRef.current = selectedCompanyId;
      isInitialMount.current = false;
      return;
    }
    
    // Only clear tabData if:
    // 1. Company actually changed (not just initialized)
    // 2. Previous company was not null (meaning it was a real change, not initial load)
    // 3. New company is different from previous
    if (previousCompanyIdRef.current !== null && 
        previousCompanyIdRef.current !== selectedCompanyId &&
        selectedCompanyId !== null) {
      console.log('ðŸ”„ [Company Change] Clearing tabData due to company change', {
        previous: previousCompanyIdRef.current,
        current: selectedCompanyId
      });
      setTabData({});
    }
    
    // Update the ref for next comparison
    previousCompanyIdRef.current = selectedCompanyId;
  }, [selectedCompanyId]);

// Auto-select first employee tab when employees are selected
useEffect(() => {
  const selectedEmpIds = Object.keys(selectedEmployees).filter(id => selectedEmployees[id]);
  if (selectedEmpIds.length > 0 && !selectedEmployeeTab) {
    setSelectedEmployeeTab(selectedEmpIds[0]);
  } else if (selectedEmpIds.length === 0) {
    setSelectedEmployeeTab(null);
  } else if (selectedEmployeeTab && !selectedEmployees[selectedEmployeeTab]) {
    // If current tab employee was removed, switch to first available
    setSelectedEmployeeTab(selectedEmpIds[0] || null);
  }
}, [selectedEmployees, selectedEmployeeTab]);

  // Don't clear selections when switching client tabs - let users keep their work

  const filteredEmployees = selectedCompanyId
? employees.filter((e) => {
    if (!e.active) return false; // Exclude inactive employees
    
    // Company filter: Check if employee has relationships with clients from this company
    const matchCompany = e.clientPayTypeRelationships?.some(rel => {
      // Find the client for this relationship
      const client = clients.find(c => c.id === rel.clientId);
      // Check if this client belongs to the selected company
      return client && client.companyIds && client.companyIds.includes(selectedCompanyId);
    }) || false;
    
    // Client filter (if a specific client is selected)
    if (selectedClientId) {
      const matchClient = e.clientPayTypeRelationships?.some(rel => rel.clientId === selectedClientId) ||
                         e.clientId === selectedClientId;
      return matchCompany && matchClient;
    }
    
    return matchCompany;
  })
: [];

  // Helper function to get appropriate payment methods based on selected client tab
  const getDefaultPaymentMethods = (emp: Employee) => {
    console.log(`ðŸ” [getDefaultPaymentMethods] ${emp.name}:`);
    console.log(`  - selectedClientId: ${selectedClientId}`);
    console.log(`  - emp.payType: ${emp.payType}`);
    console.log(`  - emp.payTypes:`, emp.payTypes);
    
    if (selectedClientId) {
      // Single client tab: STRICTLY use only the client's pay type
      const selectedClient = companyClients.find(c => c.id === selectedClientId);
      console.log(`  - Selected client:`, selectedClient?.name);
      
      if (selectedClient) {
        // Check if employee has a relationship with this client
        const relationship = emp.clientPayTypeRelationships?.find(rel => rel.clientId === selectedClientId);
        console.log(`  - Found relationship:`, relationship);
        
        if (relationship) {
          // Use the relationship's pay type
          console.log(`  - Using relationship pay type: [${relationship.payType}]`);
          return [relationship.payType];
        }
        
        // If no relationship found, determine pay type from client name
        // This is a fallback for legacy employees without relationships
        if (selectedClient.name.toLowerCase().includes('per diem') || selectedClient.name.toLowerCase().includes('perdiem')) {
          console.log(`  - Client name indicates per diem, returning: ['perdiem']`);
          return ['perdiem'];
        } else if (selectedClient.name.toLowerCase().includes('hourly')) {
          console.log(`  - Client name indicates hourly, returning: ['hourly']`);
          return ['hourly'];
        }
        
        // If we can't determine from client name, use employee's default
        console.log(`  - Using employee default pay type: [${emp.payType}]`);
        return [emp.payType];
      }
    }
    // Default fallback
    console.log(`  - Default fallback, returning: [${emp.payType}]`);
    return [emp.payType];
  };

  // Helper function to get default relationship IDs based on selected client tab
  const getDefaultRelationshipIds = (emp: Employee) => {
    if (selectedClientId) {
      // Auto-select ALL relationships for the current client (an employee might have multiple pay types with same client)
      const clientRelationships = emp.clientPayTypeRelationships?.filter(rel => 
        rel != null && rel.clientId === selectedClientId && rel.active
      ) || [];
      return clientRelationships.filter(rel => rel != null).map(rel => rel.id);
    }
    // Default fallback
    return [];
  };

  // Function to fetch and populate previous batch data
  const usePreviousBatch = async () => {
    if (!selectedClientId || !selectedCompanyId) {
      alert("Please select a client first.");
      return;
    }

    try {
      console.log("ðŸ” Fetching previous batch for client:", selectedClientId);
      
      // Get all checks for this company
      const checksQuery = query(
        collection(db, 'checks'),
        where('companyId', '==', selectedCompanyId),
        orderBy('date', 'desc')
      );
      
      const checksSnapshot = await getDocs(checksQuery);
      const allChecks = checksSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as any));
      
      console.log("ðŸ” Found total checks:", allChecks.length);
      
      // Get employees for the current client
      // ... existing code ...

// Line 422: usePreviousBatch function
const clientEmployees = filteredEmployees.filter(emp => {
  if (selectedClientId === 'multiple') {
    return emp.clientPayTypeRelationships && emp.clientPayTypeRelationships.length > 1;
  } else {
    return emp.clientPayTypeRelationships?.some(rel => rel.clientId === selectedClientId) ||
           emp.clientId === selectedClientId;
  }
});

// ... existing code ...
      
      console.log("ðŸ” Client employees:", clientEmployees.length);
      
      // Track tab data to distribute relationship-specific data across tabs
      const newTabData: { [key: string]: { selectedEmployees: { [key: string]: boolean }, inputs: { [key: string]: any } } } = {};
      let foundPreviousData = false;
      
      // For each employee, find their most recent check for this client
      clientEmployees.forEach(emp => {
        let latestCheck: any = null;
        
        if (selectedClientId === 'multiple') {
          // For multiple clients, find the most recent check with multiple relationships
          latestCheck = allChecks
            .filter((check: any) => 
              check.employeeId === emp.id && 
              check.clientId === 'multiple' &&
              check.relationshipDetails && 
              check.relationshipDetails.length > 1
            )
            .sort((a: any, b: any) => new Date(b.date).getTime() - new Date(a.date).getTime())[0];
        } else {
          // For single client, find the most recent check for this specific client
          latestCheck = allChecks
            .filter((check: any) => 
              check.employeeId === emp.id && 
              (check.clientId === selectedClientId || 
               (check.relationshipDetails && check.relationshipDetails.some((rel: any) => rel.clientId === selectedClientId)))
            )
            .sort((a: any, b: any) => new Date(b.date).getTime() - new Date(a.date).getTime())[0];
        }
        
        if (latestCheck) {
          console.log(`ðŸ” Found previous check for ${emp.name}:`, latestCheck);
          foundPreviousData = true;
          
          // If the check has relationshipDetails, distribute data across tabs
          if (latestCheck.relationshipDetails && latestCheck.relationshipDetails.length > 0) {
            console.log(`ðŸ” Distributing relationship data for ${emp.name} across ${latestCheck.relationshipDetails.length} tabs`);
            
            // Process each relationship and populate the corresponding tab
            latestCheck.relationshipDetails.forEach((relDetail: any) => {
              const tabId = relDetail.clientId;
              
              // Initialize tab data if it doesn't exist
              if (!newTabData[tabId]) {
                newTabData[tabId] = {
                  selectedEmployees: {},
                  inputs: {}
                };
              }
              
              // Select this employee in this tab
              newTabData[tabId].selectedEmployees[emp.id] = true;
              
              // Get the current relationship for this employee and client
              const relationship = emp.clientPayTypeRelationships?.find((rel: any) => rel.clientId === tabId);
              
              if (relationship) {
                const relId = relationship.id;
                
                // Create input data for this tab
                const tabInput: any = {
                  paymentMethods: [relDetail.payType],
                  selectedRelationshipIds: [relId],
                  checkDate: latestCheck.date ? createLocalDate(latestCheck.date) : null,
                  memo: latestCheck.memo || ""
                };
                
                // Populate relationship-specific fields
                if (relDetail.payType === 'hourly') {
                  tabInput[`${relId}_hours`] = relDetail.hours?.toString() || "";
                  tabInput[`${relId}_otHours`] = relDetail.otHours?.toString() || "";
                  tabInput[`${relId}_holidayHours`] = relDetail.holidayHours?.toString() || "";
                } else if (relDetail.payType === 'perdiem') {
                  tabInput[`${relId}_perdiemAmount`] = relDetail.perdiemAmount?.toString() || "";
                  tabInput[`${relId}_perdiemBreakdown`] = relDetail.perdiemBreakdown || false;
                  tabInput[`${relId}_perdiemMonday`] = relDetail.perdiemMonday?.toString() || "";
                  tabInput[`${relId}_perdiemTuesday`] = relDetail.perdiemTuesday?.toString() || "";
                  tabInput[`${relId}_perdiemWednesday`] = relDetail.perdiemWednesday?.toString() || "";
                  tabInput[`${relId}_perdiemThursday`] = relDetail.perdiemThursday?.toString() || "";
                  tabInput[`${relId}_perdiemFriday`] = relDetail.perdiemFriday?.toString() || "";
                  tabInput[`${relId}_perdiemSaturday`] = relDetail.perdiemSaturday?.toString() || "";
                  tabInput[`${relId}_perdiemSunday`] = relDetail.perdiemSunday?.toString() || "";
                }
                
                // Add other pay if exists
                if (relDetail.otherPay && relDetail.otherPay.length > 0) {
                  tabInput[`${relId}_otherPay`] = relDetail.otherPay;
                }
                
                newTabData[tabId].inputs[emp.id] = tabInput;
              }
            });
          } else {
            // Legacy check without relationship details - use simple distribution
            console.log(`ðŸ” Legacy check for ${emp.name} - distributing to current tab only`);
            
            if (!newTabData[selectedClientId]) {
              newTabData[selectedClientId] = {
                selectedEmployees: {},
                inputs: {}
              };
            }
            
            newTabData[selectedClientId].selectedEmployees[emp.id] = true;
            
            const defaultPaymentMethods = getDefaultPaymentMethods(emp);
            const defaultRelationshipIds = getDefaultRelationshipIds(emp);
            
            const empInput: any = {
              paymentMethods: defaultPaymentMethods,
              selectedRelationshipIds: defaultRelationshipIds,
              hours: latestCheck.hours?.toString() || "",
              otHours: latestCheck.otHours?.toString() || "",
              holidayHours: latestCheck.holidayHours?.toString() || "",
              memo: latestCheck.memo || "",
              perdiemAmount: latestCheck.perdiemAmount?.toString() || "",
              perdiemBreakdown: latestCheck.perdiemBreakdown || false,
              perdiemMonday: latestCheck.perdiemMonday?.toString() || "",
              perdiemTuesday: latestCheck.perdiemTuesday?.toString() || "",
              perdiemWednesday: latestCheck.perdiemWednesday?.toString() || "",
              perdiemThursday: latestCheck.perdiemThursday?.toString() || "",
              perdiemFriday: latestCheck.perdiemFriday?.toString() || "",
              perdiemSaturday: latestCheck.perdiemSaturday?.toString() || "",
              perdiemSunday: latestCheck.perdiemSunday?.toString() || "",
              checkDate: latestCheck.date ? createLocalDate(latestCheck.date) : null
            };
            
            // If employee has relationships, populate relationship-specific fields
            if (emp.clientPayTypeRelationships) {
              emp.clientPayTypeRelationships.forEach(relationship => {
                if (selectedClientId === 'multiple' || relationship.clientId === selectedClientId) {
                  const relId = relationship.id;
                  if (relationship.payType === 'hourly') {
                    empInput[`${relId}_hours`] = empInput.hours;
                    empInput[`${relId}_otHours`] = empInput.otHours;
                    empInput[`${relId}_holidayHours`] = empInput.holidayHours;
                  } else if (relationship.payType === 'perdiem') {
                    empInput[`${relId}_perdiemAmount`] = empInput.perdiemAmount;
                    empInput[`${relId}_perdiemBreakdown`] = empInput.perdiemBreakdown;
                    empInput[`${relId}_perdiemMonday`] = empInput.perdiemMonday;
                    empInput[`${relId}_perdiemTuesday`] = empInput.perdiemTuesday;
                    empInput[`${relId}_perdiemWednesday`] = empInput.perdiemWednesday;
                    empInput[`${relId}_perdiemThursday`] = empInput.perdiemThursday;
                    empInput[`${relId}_perdiemFriday`] = empInput.perdiemFriday;
                    empInput[`${relId}_perdiemSaturday`] = empInput.perdiemSaturday;
                    empInput[`${relId}_perdiemSunday`] = empInput.perdiemSunday;
                  }
                }
              });
            }
            
            newTabData[selectedClientId].inputs[emp.id] = empInput;
          }
        } else {
          console.log(`ðŸ” No previous check found for ${emp.name}`);
        }
      });
      
      if (foundPreviousData) {
        // Update tab data with relationship-specific data distributed across tabs
        setTabData(newTabData);
        setShowSuccessMessage(true);
        setTimeout(() => setShowSuccessMessage(false), 3000);
        
        const employeeCount = new Set(
          Object.values(newTabData).flatMap(tab => Object.keys(tab.selectedEmployees).filter(id => tab.selectedEmployees[id]))
        ).size;
        
        console.log(`âœ… Loaded previous batch data for ${employeeCount} employees across ${Object.keys(newTabData).length} tabs`);
      } else {
        alert("âŒ No previous batch data found for this client. Please create checks manually.");
      }
      
    } catch (error) {
      console.error("Error fetching previous batch:", error);
      alert("âŒ Error fetching previous batch data. Please try again.");
    }
  };

  const toggleEmployee = (id: string) => {
    const emp = employees.find(e => e.id === id);
    if (!emp) return;

    // Check if employee is currently selected before toggling
  const isCurrentlySelected = selectedEmployees[id];
  setSelectedEmployees((prev) => ({ ...prev, [id]: !prev[id] }));

  // If unchecking an employee, clear their input data to prevent validation conflicts
  if (isCurrentlySelected) {
    setInputs((prev) => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    return; // Exit early when unchecking
}
    
    // Auto-set payment methods and relationships based on selected client tab
    const defaultPaymentMethods = getDefaultPaymentMethods(emp);
    const defaultRelationshipIds = getDefaultRelationshipIds(emp);
    
    // Debug logging
    console.log(`ðŸ” [toggleEmployee] ${emp.name} (${id}):`);
    console.log(`  - selectedClientId: ${selectedClientId}`);
    console.log(`  - defaultPaymentMethods:`, defaultPaymentMethods);
    console.log(`  - defaultRelationshipIds:`, defaultRelationshipIds);
    
    setInputs((prev) => {
      // Start with any existing data, or create fresh defaults
      const existingData = prev[id] || {};
      
      // Always create baseInput with fresh payment methods and relationships
      // This ensures that after clearing and re-selecting, the employee gets proper defaults
      const baseInput: any = {
        ...existingData, // Preserve existing relationship-specific fields and other data
        // But override these core fields with fresh defaults:
        hours: "",
        otHours: "",
        holidayHours: "",
        memo: "",
        paymentMethods: defaultPaymentMethods,
        selectedRelationshipIds: defaultRelationshipIds,
        perdiemAmount: "",
        perdiemBreakdown: false,
        perdiemMonday: "",
        perdiemTuesday: "",
        perdiemWednesday: "",
        perdiemThursday: "",
        perdiemFriday: "",
        perdiemSaturday: "",
        perdiemSunday: "",
        // Auto-apply the default check date when selecting an employee
        checkDate: defaultCheckDate ? createLocalDate(defaultCheckDate) : (existingData.checkDate || null),
      };

      // If single client is selected, initialize relationship-specific fields
      if (selectedClientId !== 'multiple' && emp.clientPayTypeRelationships) {
        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
        if (relationship) {
          // Initialize relationship-specific fields
          baseInput[`${relationship.id}_perdiemBreakdown`] = baseInput[`${relationship.id}_perdiemBreakdown`] || false;
          baseInput[`${relationship.id}_perdiemAmount`] = baseInput[`${relationship.id}_perdiemAmount`] || "";
          baseInput[`${relationship.id}_perdiemMonday`] = baseInput[`${relationship.id}_perdiemMonday`] || "";
          baseInput[`${relationship.id}_perdiemTuesday`] = baseInput[`${relationship.id}_perdiemTuesday`] || "";
          baseInput[`${relationship.id}_perdiemWednesday`] = baseInput[`${relationship.id}_perdiemWednesday`] || "";
          baseInput[`${relationship.id}_perdiemThursday`] = baseInput[`${relationship.id}_perdiemThursday`] || "";
          baseInput[`${relationship.id}_perdiemFriday`] = baseInput[`${relationship.id}_perdiemFriday`] || "";
          baseInput[`${relationship.id}_perdiemSaturday`] = baseInput[`${relationship.id}_perdiemSaturday`] || "";
          baseInput[`${relationship.id}_perdiemSunday`] = baseInput[`${relationship.id}_perdiemSunday`] || "";
          
          // Also initialize hourly fields if needed
          if (relationship.payType === 'hourly') {
            baseInput[`${relationship.id}_hours`] = baseInput[`${relationship.id}_hours`] || "";
            baseInput[`${relationship.id}_otHours`] = baseInput[`${relationship.id}_otHours`] || "";
            baseInput[`${relationship.id}_holidayHours`] = baseInput[`${relationship.id}_holidayHours`] || "";
            baseInput[`${relationship.id}_otherPay`] = baseInput[`${relationship.id}_otherPay`] || [];
          }
          
          // Debug logging
          console.log(`ðŸ” DEBUG initialized relationship fields for ${emp.name}:`, {
            relationshipId: relationship.id,
            perdiemBreakdown: baseInput[`${relationship.id}_perdiemBreakdown`],
            perdiemMonday: baseInput[`${relationship.id}_perdiemMonday`],
            perdiemTuesday: baseInput[`${relationship.id}_perdiemTuesday`],
            perdiemWednesday: baseInput[`${relationship.id}_perdiemWednesday`]
          });
        }
      }

      return {
        ...prev,
        [id]: baseInput,
      };
    });
  };

  const handleInputChange = (id: string, field: string, value: string | string[] | boolean | OtherPayItem[] | Date | null) => {
    setInputs((prev) => ({
      ...prev,
      [id]: { ...prev[id], [field]: value },
    }));
  };

  const calculateHourlyTotal = (emp: Employee, data: PayInput) => {
    const baseRate = getEffectivePayRate(emp, data, 'hourly');
    const hours = parseFloat(data.hours) || 0;
    const otHours = parseFloat(data.otHours) || 0;
    const holidayHours = parseFloat(data.holidayHours) || 0;
    
    // Add Other Pay amounts
    const otherPayTotal = (data.otherPay || []).reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);

    return (hours * baseRate + otHours * baseRate * 1.5 + holidayHours * baseRate * 2 + otherPayTotal).toFixed(2);
  };

  // New function to calculate hourly total for a specific relationship
  const calculateHourlyTotalForRelationship = (emp: Employee, data: PayInput, relationshipId: string) => {
    const baseRate = getRelationshipPayRate(emp, relationshipId);
    const hours = parseFloat((data as any)[`${relationshipId}_hours`]) || 0;
    const otHours = parseFloat((data as any)[`${relationshipId}_otHours`]) || 0;
    const holidayHours = parseFloat((data as any)[`${relationshipId}_holidayHours`]) || 0;
    
    // Add Other Pay amounts for this relationship
    const otherPayTotal = ((data as any)[`${relationshipId}_otherPay`] || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);

    return (hours * baseRate + otHours * baseRate * 1.5 + holidayHours * baseRate * 2 + otherPayTotal).toFixed(2);
  };

  const calculatePerDiemTotal = (data: PayInput) => {
    let perDiemTotal = 0;
    
    if (data.perdiemBreakdown) {
      // Calculate from daily breakdown
      const monday = parseFloat(data.perdiemMonday || '0') || 0;
      const tuesday = parseFloat(data.perdiemTuesday || '0') || 0;
      const wednesday = parseFloat(data.perdiemWednesday || '0') || 0;
      const thursday = parseFloat(data.perdiemThursday || '0') || 0;
      const friday = parseFloat(data.perdiemFriday || '0') || 0;
      const saturday = parseFloat(data.perdiemSaturday || '0') || 0;
      const sunday = parseFloat(data.perdiemSunday || '0') || 0;
      
      perDiemTotal = monday + tuesday + wednesday + thursday + friday + saturday + sunday;
    } else {
      // Use full amount
      perDiemTotal = parseFloat(data.perdiemAmount || '0') || 0;
    }
    
    // Add Other Pay amounts for legacy per diem
    const otherPayTotal = (data.otherPay || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);
    
    return (perDiemTotal + otherPayTotal).toFixed(2);
  };

  // New function to calculate per diem total for a specific relationship
  const calculatePerDiemTotalForRelationship = (data: PayInput, relationshipId: string) => {
    const perdiemBreakdown = (data as any)[`${relationshipId}_perdiemBreakdown`];
    
    let perDiemTotal = 0;
    
    if (perdiemBreakdown) {
      // Calculate from daily breakdown
      const monday = parseFloat((data as any)[`${relationshipId}_perdiemMonday`] || '0') || 0;
      const tuesday = parseFloat((data as any)[`${relationshipId}_perdiemTuesday`] || '0') || 0;
      const wednesday = parseFloat((data as any)[`${relationshipId}_perdiemWednesday`] || '0') || 0;
      const thursday = parseFloat((data as any)[`${relationshipId}_perdiemThursday`] || '0') || 0;
      const friday = parseFloat((data as any)[`${relationshipId}_perdiemFriday`] || '0') || 0;
      const saturday = parseFloat((data as any)[`${relationshipId}_perdiemSaturday`] || '0') || 0;
      const sunday = parseFloat((data as any)[`${relationshipId}_perdiemSunday`] || '0') || 0;
      
      perDiemTotal = monday + tuesday + wednesday + thursday + friday + saturday + sunday;
    } else {
      // Use full amount
      perDiemTotal = parseFloat((data as any)[`${relationshipId}_perdiemAmount`] || '0') || 0;
    }
    
    // Add Other Pay amounts for this relationship
    const otherPayTotal = ((data as any)[`${relationshipId}_otherPay`] || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);
    
    return (perDiemTotal + otherPayTotal).toFixed(2);
  };

  // Helper function to get the correct pay rate for an employee based on selected relationships
  const getEffectivePayRate = (emp: Employee, data: PayInput, payType: 'hourly' | 'perdiem') => {
    if (data.selectedRelationshipIds && data.selectedRelationshipIds.length > 0) {
      const relationship = emp.clientPayTypeRelationships?.find(rel => 
        rel.payType === payType && 
        data.selectedRelationshipIds?.includes(rel.id)
      );
      if (relationship?.payRate) {
        return parseFloat(relationship.payRate);
      }
    }
    return emp.payRate || 0;
  };

  // Helper function to get the pay rate for a specific relationship
  const getRelationshipPayRate = (emp: Employee, relationshipId: string) => {
    const relationship = emp.clientPayTypeRelationships?.find(rel => rel.id === relationshipId);
    console.log('ðŸ” DEBUG getRelationshipPayRate:', {
      employeeName: emp.name,
      relationshipId,
      relationship,
      relationshipPayRate: relationship?.payRate,
      empDefaultPayRate: emp.payRate
    });
    if (relationship?.payRate) {
      return parseFloat(relationship.payRate);
    }
    return emp.payRate || 0;
  };

  const calculateAmount = (emp: Employee, data: PayInput) => {
    let total = 0;
    
    // If we have selected relationships, calculate from those
    if (data.selectedRelationshipIds && data.selectedRelationshipIds.length > 0) {
      // Calculate total from all selected relationships
      data.selectedRelationshipIds.forEach(relationshipId => {
        const relationship = emp.clientPayTypeRelationships?.find(rel => rel.id === relationshipId);
        if (relationship) {
          if (relationship.payType === 'hourly') {
            total += parseFloat(calculateHourlyTotalForRelationship(emp, data, relationshipId));
          } else if (relationship.payType === 'perdiem') {
            total += parseFloat(calculatePerDiemTotalForRelationship(data, relationshipId));
          }
        }
      });
    } else {
      // Handle single client scenarios - check if employee has relationship data
      if (emp.clientPayTypeRelationships && emp.clientPayTypeRelationships.length > 0) {
        // Employee has relationships - find the one for the selected client
        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
        if (relationship) {
          if (relationship.payType === 'perdiem') {
            // For per diem relationships, look for relationship-specific data
            const relationshipId = relationship.id;
            const perdiemAmount = parseFloat(data[`${relationshipId}_perdiemAmount`] || '0');
            const perdiemBreakdown = data[`${relationshipId}_perdiemBreakdown`];
            
            if (perdiemBreakdown) {
              // Calculate from daily breakdown
              const dailyTotal = ['perdiemMonday', 'perdiemTuesday', 'perdiemWednesday', 
                                 'perdiemThursday', 'perdiemFriday', 'perdiemSaturday', 'perdiemSunday']
                .reduce((sum, day) => sum + parseFloat(data[`${relationshipId}_${day}`] || '0'), 0);
              total += dailyTotal;
            } else if (perdiemAmount > 0) {
              total += perdiemAmount;
            }
            
            // Add Other Pay amounts for this relationship
            const otherPayTotal = ((data as any)[`${relationshipId}_otherPay`] || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);
            total += otherPayTotal;
          } else if (relationship.payType === 'hourly') {
            // For hourly relationships, look for relationship-specific data
            const relationshipId = relationship.id;
            const baseRate = relationship.payRate ? parseFloat(relationship.payRate) : (emp.payRate || 0);
            const hours = parseFloat(data[`${relationshipId}_hours`] || '0');
            const otHours = parseFloat(data[`${relationshipId}_otHours`] || '0');
            const holidayHours = parseFloat(data[`${relationshipId}_holidayHours`] || '0');

            total += hours * baseRate + otHours * baseRate * 1.5 + holidayHours * baseRate * 2;
            
            // Add Other Pay amounts for this relationship
            const otherPayTotal = ((data as any)[`${relationshipId}_otherPay`] || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);
            console.log(`ðŸ” [calculateAmount] ${emp.name} - relationship ${relationshipId}:`, {
              otherPayItems: (data as any)[`${relationshipId}_otherPay`] || [],
              otherPayTotal,
              totalBeforeOtherPay: total,
              totalAfterOtherPay: total + otherPayTotal
            });
            total += otherPayTotal;
          }
        }
      } else {
        // Fallback to old calculation method for legacy employees
        const paymentMethods = data.paymentMethods || [emp.payType];
      
        if (paymentMethods.includes('perdiem')) {
          const perdiemTotal = parseFloat(calculatePerDiemTotal(data));
          total += perdiemTotal;
        }
        
        if (paymentMethods.includes('hourly')) {
          const baseRate = getEffectivePayRate(emp, data, 'hourly');
          const hours = parseFloat(data.hours) || 0;
          const otHours = parseFloat(data.otHours) || 0;
          const holidayHours = parseFloat(data.holidayHours) || 0;

          total += hours * baseRate + otHours * baseRate * 1.5 + holidayHours * baseRate * 2;
          
          // Add Other Pay amounts for legacy employees
          const otherPayTotal = (data.otherPay || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);
          console.log(`ðŸ” [calculateAmount] ${emp.name} - legacy calculation:`, {
            otherPayItems: data.otherPay || [],
            otherPayTotal,
            totalBeforeOtherPay: total,
            totalAfterOtherPay: total + otherPayTotal
          });
          total += otherPayTotal;
        }
      }
    }

    console.log(`ðŸ” [calculateAmount] ${emp.name} - FINAL TOTAL:`, total.toFixed(2));
    return total.toFixed(2);
  };

  // Helper function to get ISO week number
  const getISOWeek = (date: Date): number => {
    const d = new Date(date.getTime());
    d.setHours(0, 0, 0, 0);
    // Thursday in current week decides the year
    d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
    // January 4 is always in week 1
    const week1 = new Date(d.getFullYear(), 0, 4);
    // Adjust to Thursday in week 1 and count weeks
    const week = 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
    return week;
  };

  const handleCreateChecks = async () => {
    if (!selectedCompanyId) {
      alert("Please select a company first.");
      return;
    }

    // NEW: Aggregate selected employees from ALL tabs
    const aggregatedEmployeeData: { [empId: string]: { 
      selected: boolean; 
      inputsFromTabs: Array<{ clientId: string; data: PayInput }> 
    }} = {};
    
    // Loop through all tabs in tabData
    Object.keys(tabData).forEach(tabClientId => {
      const tabInfo = tabData[tabClientId];
      if (!tabInfo) return;
      
      // For each selected employee in this tab
      Object.keys(tabInfo.selectedEmployees).forEach(empId => {
        if (tabInfo.selectedEmployees[empId] && tabInfo.inputs[empId]) {
          // Initialize employee data if not exists
          if (!aggregatedEmployeeData[empId]) {
            aggregatedEmployeeData[empId] = {
              selected: true,
              inputsFromTabs: []
            };
          }
          
          // Add this tab's data to the employee's aggregated data
          aggregatedEmployeeData[empId].inputsFromTabs.push({
            clientId: tabClientId,
            data: tabInfo.inputs[empId]
          });
        }
      });
    });
    
    const selectedEmployeeIds = Object.keys(aggregatedEmployeeData).filter(
      (id) => aggregatedEmployeeData[id].selected
    );
    
    if (selectedEmployeeIds.length === 0) {
      alert("Please select at least one employee.");
      return;
    }

    // Sort selected employee IDs alphabetically by first name to maintain consistent check number order
    selectedEmployeeIds.sort((idA, idB) => {
      const empA = employees.find(e => e.id === idA);
      const empB = employees.find(e => e.id === idB);
      if (!empA || !empB) return 0;
      const firstNameA = empA.name.split(' ')[0].toLowerCase();
      const firstNameB = empB.name.split(' ')[0].toLowerCase();
      return firstNameA.localeCompare(firstNameB);
    });

    // Validate all selected employees - check each tab where they're selected
    for (const empId of selectedEmployeeIds) {
      const emp = employees.find((e) => e.id === empId);
      if (!emp) continue;

      // Get data from ALL tabs this employee is selected in
      const empData = aggregatedEmployeeData[empId];
      if (!empData || empData.inputsFromTabs.length === 0) {
        alert(`Please fill in data for ${emp.name}`);
        return;
      }

      // Check if employee has payment data in AT LEAST ONE of their selected tabs
      let hasDataInAnyTab = false;
      
      for (const tabInfo of empData.inputsFromTabs) {
        const data = tabInfo.data;
        const tabClientId = tabInfo.clientId;
        
        // Validation based on ACTUAL DATA entered for this specific tab
        let hasHourlyData = false;
        let hasPerDiemData = false;
        
        // Check relationship-specific fields for this tab's client
        if (data.selectedRelationshipIds && data.selectedRelationshipIds.length > 0) {
          // Check relationship-specific fields for this client
          const relationships = emp.clientPayTypeRelationships?.filter(rel => 
            data.selectedRelationshipIds!.includes(rel.id) && rel.clientId === tabClientId
          ) || [];
          
          for (const rel of relationships) {
            if (rel.payType === 'hourly') {
              const relHours = parseFloat(data[`${rel.id}_hours`] || '0');
              const relOtHours = parseFloat(data[`${rel.id}_otHours`] || '0');
              const relHolidayHours = parseFloat(data[`${rel.id}_holidayHours`] || '0');
              if (relHours > 0 || relOtHours > 0 || relHolidayHours > 0) {
                hasHourlyData = true;
              }
            } else if (rel.payType === 'perdiem') {
              const relAmount = parseFloat(data[`${rel.id}_perdiemAmount`] || '0');
              const relBreakdown = data[`${rel.id}_perdiemBreakdown`];
              
              if (relBreakdown) {
                // Check daily breakdown
                const hasDailyData = ['perdiemMonday', 'perdiemTuesday', 'perdiemWednesday', 
                                     'perdiemThursday', 'perdiemFriday', 'perdiemSaturday', 'perdiemSunday']
                  .some(day => parseFloat(data[`${rel.id}_${day}`] || '0') > 0);
                if (hasDailyData) {
                  hasPerDiemData = true;
                }
              } else if (relAmount > 0) {
                hasPerDiemData = true;
              }
            }
          }
        } else {
          // Check basic fields
          hasHourlyData = parseFloat(data.hours || '0') > 0 || 
                         parseFloat(data.otHours || '0') > 0 || 
                         parseFloat(data.holidayHours || '0') > 0;
          
          // Also check if there are relationship-specific fields
          if (emp.clientPayTypeRelationships) {
            const clientRelationship = emp.clientPayTypeRelationships.find(rel => 
              rel.clientId === tabClientId
            );
            
            if (clientRelationship) {
              if (clientRelationship.payType === 'hourly') {
                // Check for relationship-specific hourly data
                const relHours = parseFloat(data[`${clientRelationship.id}_hours`] || '0');
                const relOtHours = parseFloat(data[`${clientRelationship.id}_otHours`] || '0');
                const relHolidayHours = parseFloat(data[`${clientRelationship.id}_holidayHours`] || '0');
                hasHourlyData = relHours > 0 || relOtHours > 0 || relHolidayHours > 0;
              } else if (clientRelationship.payType === 'perdiem') {
                // Check for relationship-specific per diem data
                const relAmount = parseFloat(data[`${clientRelationship.id}_perdiemAmount`] || '0');
                const relBreakdown = data[`${clientRelationship.id}_perdiemBreakdown`];
                
                if (relBreakdown) {
                  // Check daily breakdown
                  const hasDailyData = ['perdiemMonday', 'perdiemTuesday', 'perdiemWednesday', 
                                       'perdiemThursday', 'perdiemFriday', 'perdiemSaturday', 'perdiemSunday']
                    .some(day => parseFloat(data[`${clientRelationship.id}_${day}`] || '0') > 0);
                  hasPerDiemData = hasDailyData;
                } else {
                  hasPerDiemData = relAmount > 0;
                }
              }
            }
          }
          
          // Fallback to basic fields if no relationship data found
          if (!hasHourlyData && !hasPerDiemData) {
            // Check basic per diem fields
            hasPerDiemData = parseFloat(calculatePerDiemTotal(data)) > 0;
            
            // Also check basic hourly fields
            hasHourlyData = parseFloat(data.hours || '0') > 0 || 
                           parseFloat(data.otHours || '0') > 0 || 
                           parseFloat(data.holidayHours || '0') > 0;
          }
        }
        
        // If this tab has data, mark it
        if (hasHourlyData || hasPerDiemData) {
          hasDataInAnyTab = true;
          break; // No need to check other tabs if we found data in one
        }
      }
      
      // Only fail validation if employee has NO data in ANY of their selected tabs
      if (!hasDataInAnyTab) {
        const clientNames = empData.inputsFromTabs.map(t => {
          const client = companyClients.find(c => c.id === t.clientId);
          return client?.name || 'Unknown';
        }).join(', ');
        alert(`Please enter payment data (hours or per diem) for ${emp.name} in at least one of their selected clients: ${clientNames}`);
        return;
      }
    }

    setIsCreatingChecks(true);

    try {
      // âœ… FIXED: Get nextCheckNumber from BANK, not company
      console.log("ðŸ” DEBUG: Getting nextCheckNumber from BANK...");
      console.log("ðŸ” DEBUG: Company ID:", selectedCompanyId);
      
      // First, get the bank associated with this company
      const banksQuery = query(collection(db, "banks"), where("companyId", "==", selectedCompanyId));
      console.log("ðŸ” DEBUG: Executing bank query:", {
        collection: "banks",
        whereField: "companyId",
        whereValue: selectedCompanyId
      });
      
      const banksSnapshot = await getDocs(banksQuery);
      console.log("ðŸ” DEBUG: Bank query result:", {
        empty: banksSnapshot.empty,
        size: banksSnapshot.size,
        docs: banksSnapshot.docs.map(doc => ({ id: doc.id, data: doc.data() }))
      });
      
      if (banksSnapshot.empty) {
        console.error("âŒ ERROR: No bank found for company:", selectedCompanyId);
        throw new Error(`No bank found for company ${selectedCompanyId}`);
      }
      
      const bankDoc = banksSnapshot.docs[0];
      const bankId = bankDoc.id;
      const bankData = bankDoc.data();
      
      console.log("ðŸ” DEBUG: Found bank:", {
        bankId: bankId,
        bankName: bankData.bankName,
        companyId: bankData.companyId,
        currentNextCheckNumber: bankData.nextCheckNumber
      });
      
      // Get the next check number from bank, but ensure it starts from 100
      let nextCheckNumber = Number(bankData.nextCheckNumber) || Number(bankData.startingCheckNumber) || 1000; // Always use startingCheckNumber
      
      // Force reset if the number is too low (less than 100)
      if (nextCheckNumber < 100) {
        console.log("ðŸ” DEBUG: Check number too low, resetting to 100");
        nextCheckNumber = 100;
      }
      
      console.log("ðŸ” DEBUG: Using nextCheckNumber from bank:", nextCheckNumber);
      
      // Create checks for each selected employee
      const createdChecks: any[] = [];
      
      for (const empId of selectedEmployeeIds) {
        const emp = employees.find(e => e.id === empId);
        if (!emp) continue;
        
        // Get aggregated data from all tabs for this employee
        const empAggregatedData = aggregatedEmployeeData[empId];
        if (!empAggregatedData || empAggregatedData.inputsFromTabs.length === 0) continue;
        
        // Use the first tab's check date as the default (or current date)
        const checkDate = empAggregatedData.inputsFromTabs[0]?.data.checkDate || new Date();
        // Calculate week key as the Sunday of the week (same logic as View Checks)
        const d = new Date(checkDate);
        const weekKey = new Date(d.setDate(d.getDate() - d.getDay())).toISOString().slice(0, 10);

        // NEW: Build relationship details from ALL tabs
        let relationshipDetails: any[] = [];
        let selectedRelationshipIds: string[] = [];

        // Process data from each tab this employee was selected in
        empAggregatedData.inputsFromTabs.forEach(tabInfo => {
          const tabData = tabInfo.data;
          const tabClientId = tabInfo.clientId;
          
          if (tabData.selectedRelationshipIds && tabData.selectedRelationshipIds.length > 0) {
            // Get relationships for this tab
            const tabRelationships = emp.clientPayTypeRelationships
              ?.filter(rel => tabData.selectedRelationshipIds?.includes(rel.id) && rel.clientId === tabClientId)
              .map(rel => {
                // Get CURRENT client name (not cached one) for new checks
                const currentClient = clients.find(c => c.id === rel.clientId);
                const clientNameForCheck = currentClient?.name || rel.clientName;
                
                const relData: any = {
                  id: rel.id,
                  clientId: rel.clientId,
                  clientName: clientNameForCheck, // Use current client name for new checks
                  payType: rel.payType,
                  payRate: rel.payRate ? parseFloat(rel.payRate) : (emp.payRate || 0)
                };
                
                // Add relationship-specific hours if available
                const relHours = parseFloat((tabData as any)[`${rel.id}_hours`] || '0');
                if (relHours > 0) relData.hours = relHours;
                
                const relOtHours = parseFloat((tabData as any)[`${rel.id}_otHours`] || '0');
                if (relOtHours > 0) relData.otHours = relOtHours;
                
                const relHolidayHours = parseFloat((tabData as any)[`${rel.id}_holidayHours`] || '0');
                if (relHolidayHours > 0) relData.holidayHours = relHolidayHours;
                
                // Add relationship-specific per diem data if available
                const relPerdiemAmount = parseFloat((tabData as any)[`${rel.id}_perdiemAmount`] || '0');
                if (relPerdiemAmount > 0) relData.perdiemAmount = relPerdiemAmount;
                
                const relPerdiemBreakdown = (tabData as any)[`${rel.id}_perdiemBreakdown`];
                if (relPerdiemBreakdown !== undefined) relData.perdiemBreakdown = relPerdiemBreakdown;
                
                // Add daily per diem amounts if available
                ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].forEach(day => {
                  const dayAmount = parseFloat((tabData as any)[`${rel.id}_perdiem${day}`] || '0');
                  if (dayAmount > 0) relData[`perdiem${day}`] = dayAmount;
                });
                
                // Add relationship-specific other pay if available
                const relOtherPay = (tabData as any)[`${rel.id}_otherPay`];
                if (relOtherPay && relOtherPay.length > 0) relData.otherPay = relOtherPay;
                
                return relData;
              }) || [];
            
            relationshipDetails.push(...tabRelationships);
            selectedRelationshipIds.push(...(tabData.selectedRelationshipIds || []));
          }
        });
        
        // Determine overall client and pay type
        let clientId = relationshipDetails.length > 1 ? 'multiple' : (relationshipDetails[0]?.clientId || null);
        let payType = relationshipDetails.length > 1 ? 'mixed' : (relationshipDetails[0]?.payType || emp.payType);
        
        console.log(`ðŸ” DEBUG: Aggregated relationship details for ${emp.name}:`, relationshipDetails);
        console.log(`ðŸ” DEBUG: clientId=${clientId}, payType=${payType}, relationshipCount=${relationshipDetails.length}`);

        // Calculate aggregated totals from all relationships
        let totalHours = 0;
        let totalOtHours = 0;
        let totalHolidayHours = 0;
        let totalPerDiemAmount = 0;
        let aggregatedOtherPay: OtherPayItem[] = [];
        let aggregatedPerDiemData = {
          perdiemMonday: 0,
          perdiemTuesday: 0,
          perdiemWednesday: 0,
          perdiemThursday: 0,
          perdiemFriday: 0,
          perdiemSaturday: 0,
          perdiemSunday: 0
        };
        
        // Calculate hourly amount per relationship (using relationship-specific pay rates)
        let hourlyAmount = 0;
        
        // Aggregate data from all relationships
        for (const rel of relationshipDetails) {
          if (rel.payType === 'hourly') {
            // Use relationship-specific pay rate for this relationship's hours
            const relPayRate = rel.payRate || emp.payRate || 0;
            const relHours = rel.hours || 0;
            const relOtHours = rel.otHours || 0;
            const relHolidayHours = rel.holidayHours || 0;
            
            // Calculate hourly amount for this relationship using its specific pay rate
            hourlyAmount += (relHours * relPayRate) + (relOtHours * relPayRate * 1.5) + (relHolidayHours * relPayRate * 2);
            
            // Still track totals for display purposes
            totalHours += relHours;
            totalOtHours += relOtHours;
            totalHolidayHours += relHolidayHours;
            
            if (rel.otherPay && rel.otherPay.length > 0) {
              aggregatedOtherPay.push(...rel.otherPay);
            }
          } else if (rel.payType === 'perdiem') {
            totalPerDiemAmount += rel.perdiemAmount || 0;
            aggregatedPerDiemData.perdiemMonday += rel.perdiemMonday || 0;
            aggregatedPerDiemData.perdiemTuesday += rel.perdiemTuesday || 0;
            aggregatedPerDiemData.perdiemWednesday += rel.perdiemWednesday || 0;
            aggregatedPerDiemData.perdiemThursday += rel.perdiemThursday || 0;
            aggregatedPerDiemData.perdiemFriday += rel.perdiemFriday || 0;
            aggregatedPerDiemData.perdiemSaturday += rel.perdiemSaturday || 0;
            aggregatedPerDiemData.perdiemSunday += rel.perdiemSunday || 0;
            if (rel.otherPay && rel.otherPay.length > 0) {
              aggregatedOtherPay.push(...rel.otherPay);
            }
          }
        }
        
        // Calculate total amount
        // Add daily per diem breakdown to totalPerDiemAmount if it exists
        const dailyPerDiemTotal = Object.values(aggregatedPerDiemData).reduce((sum, val) => sum + val, 0);
        const finalPerDiemAmount = totalPerDiemAmount + dailyPerDiemTotal;
        
        const otherPayTotal = aggregatedOtherPay.reduce((sum, item) => sum + parseFloat(item.amount || '0'), 0);
        const totalAmount = hourlyAmount + finalPerDiemAmount + otherPayTotal;

        // Prepare check data
        const checkData: any = {
          companyId: selectedCompanyId,
          employeeName: emp.name,
          employeeId: emp.id,
          amount: totalAmount,
          hours: totalHours,
          otHours: totalOtHours,
          holidayHours: totalHolidayHours,
          perdiemAmount: finalPerDiemAmount || 0,
          otherPay: aggregatedOtherPay.map((item: OtherPayItem) => ({
            ...item,
            description: item.description && item.description.trim() !== '' ? item.description : 'Other Pay'
          })),
          memo: empAggregatedData.inputsFromTabs[0]?.data.memo || '',
          paymentMethods: relationshipDetails.map(r => r.payType),
          selectedRelationshipIds: selectedRelationshipIds,
          relationshipDetails: relationshipDetails,
          clientId: clientId,
          payType: payType,
          payRate: emp.payRate?.toString() || '',
          weekKey: weekKey,
          workWeek: getISOWeek(checkDate).toString(),
          date: checkDate.toISOString().split('T')[0],
          createdBy: auth.currentUser?.uid,
          reviewed: false,
          paid: false,
          checkNumber: nextCheckNumber + createdChecks.length,
        };

        // Always add daily per diem breakdown fields for consistent data format
        Object.assign(checkData, aggregatedPerDiemData);
        
        console.log(`ðŸ” DEBUG: Final checkData for ${emp.name}:`, checkData);
        
        console.log('ðŸ” DEBUG: Final checkData being saved to Firestore:', {
          checkId: checkData.id || 'NEW_CHECK',
          employeeId: checkData.employeeId,
          employeeName: checkData.employeeName,
          amount: checkData.amount,
          hours: checkData.hours,
          otHours: checkData.otHours,
          holidayHours: checkData.holidayHours,
          perdiemAmount: checkData.perdiemAmount,
          relationshipDetails: checkData.relationshipDetails,
          relationshipDetailsJSON: JSON.stringify(checkData.relationshipDetails, null, 2)
        });
        checkData.selectedRelationshipIds = selectedRelationshipIds;

        console.log("ðŸ” DEBUG: Data after cleanup:", checkData);
        console.log("ðŸ” DEBUG: Saving check data with relationships:", relationshipDetails.length, checkData);
        console.log("ðŸ” DEBUG: relationshipDetails:", relationshipDetails);
        console.log("ðŸ” DEBUG: Check data to be saved:", JSON.stringify(checkData, null, 2));

        // Save to Firestore
        const checkRef = doc(collection(db, "checks"));
        console.log("ðŸ” DEBUG: Check reference created:", checkRef.path);
        console.log("ðŸ” DEBUG: About to save check with data:", {
          companyId: checkData.companyId,
          employeeName: checkData.employeeName,
          amount: checkData.amount,
          hours: checkData.hours,
          payType: checkData.payType,
          employeeId: checkData.employeeId,
          clientId: checkData.clientId,
          weekKey: checkData.weekKey,
          createdBy: checkData.createdBy,
          reviewed: checkData.reviewed,
          paid: checkData.paid,
          checkNumber: checkData.checkNumber
        });

        try {
          await setDoc(checkRef, checkData);
          console.log("âœ… Check saved successfully!");
          createdChecks.push(checkData);
        } catch (saveError: any) {
          console.log("âŒ Error saving individual check:", {
            message: saveError.message,
            code: saveError.code,
            stack: saveError.stack
          });
          throw saveError; // Re-throw to maintain existing error handling
        }
      }

      // âœ… FIXED: Update BANK's nextCheckNumber, not company
      if (createdChecks.length > 0) {
        console.log("ðŸ” DEBUG: About to update BANK with new check number");
        console.log("ðŸ” DEBUG: Bank ID:", bankId);
        console.log("ðŸ” DEBUG: Current nextCheckNumber:", nextCheckNumber);
        console.log("ðŸ” DEBUG: Created checks count:", createdChecks.length);
        console.log("ðŸ” DEBUG: New nextCheckNumber will be:", Number(nextCheckNumber) + createdChecks.length);
        
        const bankRef = doc(db, "banks", bankId);
        console.log("ðŸ” DEBUG: Bank reference created:", bankRef.path);
        
        try {
          await updateDoc(bankRef, {
            nextCheckNumber: Number(nextCheckNumber) + createdChecks.length
          });
          console.log("âœ… Bank updated successfully!");
        } catch (bankUpdateError: any) {
          console.log("âŒ Error updating bank:", {
            message: bankUpdateError.message,
            code: bankUpdateError.code,
            stack: bankUpdateError.stack
          });
          throw bankUpdateError;
        }
      }

      console.log("ðŸ” DEBUG: All operations completed successfully, about to show success message");
      console.log(`âœ… Successfully created ${createdChecks.length} checks`);
      setShowSuccessMessage(true);
      
      // Clear all selections and inputs from all tabs to start fresh
      console.log("ðŸ” DEBUG: Clearing all tab data (selections and inputs) to start fresh");
      setTabData({});
      
      // Clear saved data from localStorage since checks were successfully created
      clearSavedData();
      
      // Show floating menu with navigation options
      const company = companies.find(c => c.id === selectedCompanyId);
      const client = createdChecks[0]?.clientId && createdChecks[0].clientId !== 'multiple' 
        ? clients.find(c => c.id === createdChecks[0].clientId) 
        : null;
      
      console.log('ðŸ” DEBUG: Success message - selectedCompanyId:', selectedCompanyId);
      console.log('ðŸ” DEBUG: Success message - found company:', company?.name);
      console.log('ðŸ” DEBUG: Success message - found client:', client?.name);
      
      setFloatingMenu({
        open: true,
        companyId: selectedCompanyId,
        clientId: createdChecks[0]?.clientId && createdChecks[0].clientId !== 'multiple' ? createdChecks[0].clientId : null,
        checkId: createdChecks[0]?.id || null,
        companyName: company?.name || 'Unknown Company',
        clientName: client?.name || (createdChecks[0]?.clientId === 'multiple' ? 'Multiple Clients' : 'Unknown Client')
      });
      
      // Clear selections and inputs
    setSelectedEmployees({});
    setInputs({});
      // Don't reset selectedClientId - keep the current client selected
      
      // Trigger refresh of checks data
      if (onChecksCreated) {
        onChecksCreated();
      }

    } catch (error: any) {
      console.error("âŒ Error creating checks:", error);
      console.error("âŒ Full error details:", {
        message: error.message,
        code: error.code,
        stack: error.stack,
        name: error.name
      });
      
      // Try to provide more specific error information
      if (error.code === 'permission-denied') {
        console.error("âŒ Permission denied - check Firestore rules");
      } else if (error.code === 'unavailable') {
        console.error("âŒ Service unavailable - check network connection");
      } else if (error.code === 'not-found') {
        console.error("âŒ Collection not found");
      } else if (error.code === 'invalid-argument') {
        console.error("âŒ Invalid argument - check data format");
      } else if (error.code === 'failed-precondition') {
        console.error("âŒ Failed precondition - check data requirements");
      }
      
      alert("Error creating checks. Please try again.");
    } finally {
      setIsCreatingChecks(false);
    }
  };

  const reviewChecks = () => {
    if (!selectedCompanyId) {
      alert("Please select a company first.");
      return;
    }

    console.log(`ðŸ” [Review] selectedClientId: ${selectedClientId}`);
    console.log(`ðŸ” [Review] companyClients:`, companyClients.filter(c => c != null).map(c => ({ id: c.id, name: c.name })));
    console.log(`ðŸ” [Review] tabData:`, tabData);

    // Aggregate employees from ALL tabs
    const allSelectedEmployeeIds = new Set<string>();
    Object.values(tabData).forEach(tab => {
      Object.keys(tab.selectedEmployees).forEach(empId => {
        if (tab.selectedEmployees[empId]) {
          allSelectedEmployeeIds.add(empId);
        }
      });
    });

    if (allSelectedEmployeeIds.size === 0) {
      alert("Please select at least one employee.");
      return;
    }

    console.log(`ðŸ” [Review] Found ${allSelectedEmployeeIds.size} employees across all tabs`);

    // Prepare review data - aggregate amounts from ALL tabs for each employee
    const reviewDataArray = Array.from(allSelectedEmployeeIds).map(empId => {
      const emp = employees.find((e) => e.id === empId);
      if (!emp) return null;

      let totalAmount = 0;
      let hourlyTotal = 0;
      let perDiemTotal = 0;
      const clientsWorked: string[] = [];
      const clientBreakdown: Array<{
        clientId: string;
        clientName: string;
        companyName: string;
        division?: string;
        amount: number;
        hourlyAmount: number;
        perDiemAmount: number;
        payType: string;
        details: Array<{label: string; value: string}>;
      }> = [];

      // Loop through ALL tabs to aggregate this employee's data
      Object.entries(tabData).forEach(([tabId, tabInfo]) => {
        const data = tabInfo.inputs[empId];
        if (data && tabInfo.selectedEmployees[empId]) {
          const tabAmount = parseFloat(calculateAmount(emp, data));
          const tabHourly = parseFloat(calculateHourlyTotal(emp, data));
          const tabPerDiem = parseFloat(calculatePerDiemTotal(data));
          
          if (tabAmount > 0) {
            totalAmount += tabAmount;
            hourlyTotal += tabHourly;
            perDiemTotal += tabPerDiem;
            
            // Track which client this tab represents with full details
            const client = companyClients.find(c => c.id === tabId);
            if (client) {
              clientsWorked.push(client.name);
              
              // Find the company for this client
              const company = companies.find(c => client.companyIds?.includes(c.id));
              
              // Find the relationship for this client to get relationship-specific data
              const relationship = emp.clientPayTypeRelationships?.find((rel: any) => rel.clientId === tabId);
              
              // Determine pay type from the relationship's actual payType field
              const payType = relationship?.payType === 'hourly' ? 'Hourly' : 'Per Diem';
              
              // Build detailed line items for this client
              const details: Array<{label: string; value: string}> = [];
              
              if (relationship) {
                const relId = relationship.id;
                
                // Check for hourly data
                const hours = parseFloat((data as any)[`${relId}_hours`] || '0');
                const otHours = parseFloat((data as any)[`${relId}_otHours`] || '0');
                const holidayHours = parseFloat((data as any)[`${relId}_holidayHours`] || '0');
                const rate = parseFloat(relationship.payRate || '0');
                
                if (hours > 0) details.push({ label: `${hours} hrs Ã— $${rate}`, value: `$${(hours * rate).toFixed(2)}` });
                if (otHours > 0) details.push({ label: `${otHours} OT Ã— $${(rate * 1.5).toFixed(2)}`, value: `$${(otHours * rate * 1.5).toFixed(2)}` });
                if (holidayHours > 0) details.push({ label: `${holidayHours} holiday Ã— $${(rate * 2).toFixed(2)}`, value: `$${(holidayHours * rate * 2).toFixed(2)}` });
                
                // Check for per diem data
                const perdiemBreakdown = (data as any)[`${relId}_perdiemBreakdown`];
                if (perdiemBreakdown) {
                  // Daily breakdown mode
                  const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                  days.forEach(day => {
                    const dayValue = parseFloat((data as any)[`${relId}_perdiem${day}`] || '0');
                    if (dayValue > 0) {
                      details.push({ label: day, value: `$${dayValue.toFixed(2)}` });
                    }
                  });
                } else {
                  // Full amount mode
                  const perdiemAmount = parseFloat((data as any)[`${relId}_perdiemAmount`] || '0');
                  if (perdiemAmount > 0) {
                    details.push({ label: 'Per Diem', value: `$${perdiemAmount.toFixed(2)}` });
                  }
                }
                
                // Add Other Pay items
                const otherPay = (data as any)[`${relId}_otherPay`] || [];
                otherPay.forEach((item: any) => {
                  if (item.amount && parseFloat(item.amount) > 0) {
                    details.push({ 
                      label: item.description || 'Other Pay', 
                      value: `$${parseFloat(item.amount).toFixed(2)}` 
                    });
                  }
                });
              }
              
              clientBreakdown.push({
                clientId: client.id,
                clientName: client.name,
                companyName: company?.name || 'Unknown',
                division: client.division || undefined,
                amount: tabAmount,
                hourlyAmount: tabHourly,
                perDiemAmount: tabPerDiem,
                payType: payType,
                details: details
              });
            }
          }
          
          console.log(`ðŸ” [Review] ${emp.name} - ${tabId}: $${tabAmount.toFixed(2)} (hourly: $${tabHourly.toFixed(2)}, perdiem: $${tabPerDiem.toFixed(2)})`);
        }
      });

      if (totalAmount === 0) return null;

      console.log(`ðŸ” [Review] ${emp.name} - TOTAL: $${totalAmount.toFixed(2)} across ${clientsWorked.length} clients: ${clientsWorked.join(', ')}`);
      console.log(`ðŸ” [Review] ${emp.name} - Breakdown:`, clientBreakdown);

      return {
        employee: emp,
        input: {} as PayInput, // Not used for multi-tab aggregation
        calculatedAmount: totalAmount,
        hourlyTotal: hourlyTotal,
        perDiemTotal: perDiemTotal,
        clientsWorked: clientsWorked,
        clientBreakdown: clientBreakdown
      };
    }).filter((item): item is NonNullable<typeof item> => item !== null);

    console.log(`ðŸ” [Review] Final review data:`, reviewDataArray.map(r => ({ name: r.employee.name, amount: r.calculatedAmount, clients: r.clientsWorked })));

    // Sort employees alphabetically by name
    const sortedReviewData = reviewDataArray.sort((a, b) => 
      a.employee.name.localeCompare(b.employee.name)
    );

    setReviewData(sortedReviewData);
    setShowReviewPanel(true);
  };

  // Recalculate review data when review panel is restored from localStorage
  // This ensures the review panel shows correctly after a page refresh
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    // Only recalculate if:
    // 1. Review panel should be shown (restored from localStorage)
    // 2. We have tabData with selected employees or input data
    // 3. Employees and clients are loaded
    // 4. We haven't already restored (prevent infinite loops)
    if (showReviewPanel && 
        !hasRestoredReviewRef.current &&
        Object.keys(tabData).length > 0 && 
        employees.length > 0 && 
        companyClients.length > 0 &&
        selectedCompanyId) {
      
      // Check if we have any selected employees OR input data
      const hasData = Object.values(tabData).some(tab => {
        const hasSelectedEmployees = Object.keys(tab.selectedEmployees || {}).some(id => tab.selectedEmployees[id]);
        const hasInputData = Object.keys(tab.inputs || {}).length > 0;
        return hasSelectedEmployees || hasInputData;
      });
      
      if (hasData && reviewData.length === 0) {
        console.log('ðŸ”„ [Review Restore] Recalculating review data after page refresh', {
          tabDataKeys: Object.keys(tabData),
          employeesCount: employees.length,
          clientsCount: companyClients.length,
          selectedCompanyId,
          hasData
        });
        hasRestoredReviewRef.current = true;
        // Use a small delay to ensure all state is ready
        const timer = setTimeout(() => {
          reviewChecks();
        }, 200);
        return () => clearTimeout(timer);
      } else {
        console.log('ðŸ”„ [Review Restore] Conditions not met:', {
          showReviewPanel,
          hasRestored: hasRestoredReviewRef.current,
          hasTabData: Object.keys(tabData).length > 0,
          hasEmployees: employees.length > 0,
          hasClients: companyClients.length > 0,
          hasSelectedCompany: !!selectedCompanyId,
          hasData,
          reviewDataLength: reviewData.length
        });
      }
    }
    
    // Reset the ref when review panel is closed
    if (!showReviewPanel) {
      hasRestoredReviewRef.current = false;
    }
  }, [showReviewPanel, tabData, employees.length, companyClients.length, selectedCompanyId, reviewData.length]);

  const generateReviewPDF = async () => {
    if (reviewData.length === 0) {
      alert("No review data available to print.");
      return;
    }

    try {
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([612, 792]); // US Letter size
      const { width, height } = page.getSize();
      
      // Font setup
      const font = await pdfDoc.embedFont('Helvetica');
      const boldFont = await pdfDoc.embedFont('Helvetica-Bold');
      
      let yPosition = height - 50;
      const margin = 50;
      const lineHeight = 14;
      const sectionSpacing = 20;
      
      // Helper function to add text with word wrapping
      const addText = (text: string, x: number, y: number, size: number, isBold: boolean = false, maxWidth?: number, targetPage = page) => {
        const fontToUse = isBold ? boldFont : font;
        if (maxWidth) {
          // Simple word wrapping
          const words = text.split(' ');
          let line = '';
          let currentY = y;
          for (const word of words) {
            const testLine = line + (line ? ' ' : '') + word;
            const textWidth = fontToUse.widthOfTextAtSize(testLine, size);
            if (textWidth > maxWidth && line) {
              targetPage.drawText(line, { x, y: currentY, size, font: fontToUse });
              line = word;
              currentY -= size + 2;
            } else {
              line = testLine;
            }
          }
          if (line) {
            targetPage.drawText(line, { x, y: currentY, size, font: fontToUse });
          }
          return currentY;
        } else {
          targetPage.drawText(text, { x, y, size, font: fontToUse });
          return y;
        }
      };
      
      // Header
      let currentPage = page;
      const companyName = companies.find(c => c.id === selectedCompanyId)?.name || 'Unknown Company';
      addText('Payroll Checks Review', margin, yPosition, 18, true, undefined, currentPage);
      yPosition -= 25;
      addText(`Company: ${companyName}`, margin, yPosition, 12, false, undefined, currentPage);
      yPosition -= 15;
      addText(`Generated: ${new Date().toLocaleString()}`, margin, yPosition, 10, false, undefined, currentPage);
      yPosition -= sectionSpacing * 2;
      
      // Get all unique clients
      const allClientsMap = new Map<string, { clientId: string; clientName: string; division?: string }>();
      reviewData.forEach(item => {
        if (item.clientBreakdown) {
          item.clientBreakdown.forEach(breakdown => {
            const uniqueKey = breakdown.clientId;
            if (!allClientsMap.has(uniqueKey)) {
              allClientsMap.set(uniqueKey, {
                clientId: breakdown.clientId,
                clientName: breakdown.clientName,
                division: breakdown.division
              });
            }
          });
        }
      });
      
      const clientList = Array.from(allClientsMap.keys()).sort();
      const clientTotals = clientList.map(uniqueKey => {
        const clientInfo = allClientsMap.get(uniqueKey)!;
        const total = reviewData.reduce((sum, item) => {
          const breakdown = item.clientBreakdown?.find(b => b.clientId === uniqueKey);
          return sum + (breakdown?.amount || 0);
        }, 0);
        const displayName = clientInfo.division && clientInfo.division.trim()
          ? `${clientInfo.clientName} (${clientInfo.division})`
          : clientInfo.clientName;
        return { 
          uniqueKey,
          clientId: clientInfo.clientId,
          clientName: clientInfo.clientName,
          division: clientInfo.division,
          displayName,
          total 
        };
      });
      
      // Summary by Client/Department
      addText('Summary by Client/Department', margin, yPosition, 14, true, undefined, currentPage);
      yPosition -= 20;
      
      // Table header
      addText('Client/Department', margin, yPosition, 10, true, undefined, currentPage);
      addText('Total Amount', width - margin - 150, yPosition, 10, true, undefined, currentPage);
      addText('Employees', width - margin - 50, yPosition, 10, true, undefined, currentPage);
      yPosition -= 15;
      
      // Draw line
      currentPage.drawLine({
        start: { x: margin, y: yPosition },
        end: { x: width - margin, y: yPosition },
        thickness: 1,
        color: rgb(0, 0, 0)
      });
      yPosition -= 10;
      
      // Client totals
      clientTotals.forEach(({ uniqueKey, displayName, total }) => {
        if (yPosition < 100) {
          // New page
          currentPage = pdfDoc.addPage([612, 792]);
          yPosition = height - 50;
        }
        
        const employeeCount = reviewData.filter(item => 
          item.clientBreakdown?.some(b => b.clientId === uniqueKey)
        ).length;
        
        addText(displayName, margin, yPosition, 10, false, undefined, currentPage);
        addText(`$${total.toFixed(2)}`, width - margin - 150, yPosition, 10, false, undefined, currentPage);
        addText(`${employeeCount}`, width - margin - 50, yPosition, 10, false, undefined, currentPage);
        yPosition -= 15;
      });
      
      // Grand Total
      yPosition -= 5;
      currentPage.drawLine({
        start: { x: margin, y: yPosition },
        end: { x: width - margin, y: yPosition },
        thickness: 1,
        color: rgb(0, 0, 0)
      });
      yPosition -= 10;
      
      const grandTotal = reviewData.reduce((sum, item) => sum + item.calculatedAmount, 0);
      addText('GRAND TOTAL', margin, yPosition, 12, true, undefined, currentPage);
      addText(`$${grandTotal.toFixed(2)}`, width - margin - 150, yPosition, 12, true, undefined, currentPage);
      addText(`${reviewData.length}`, width - margin - 50, yPosition, 12, true, undefined, currentPage);
      yPosition -= sectionSpacing * 2;
      
      // Employee Breakdown for each client
      clientList.forEach(uniqueKey => {
        if (yPosition < 150) {
          currentPage = pdfDoc.addPage([612, 792]);
          yPosition = height - 50;
        }
        
        const clientInfo = allClientsMap.get(uniqueKey)!;
        const displayName = clientInfo.division && clientInfo.division.trim()
          ? `${clientInfo.clientName} (${clientInfo.division})`
          : clientInfo.clientName;
        
        addText(`Employee Breakdown: ${displayName}`, margin, yPosition, 14, true, undefined, currentPage);
        yPosition -= 20;
        
        const employeesForClient = reviewData.filter(item => {
          return item.clientBreakdown?.some(b => b.clientId === uniqueKey);
        });
        
        // Table header
        addText('Employee', margin, yPosition, 10, true, undefined, currentPage);
        addText('Pay Type', margin + 200, yPosition, 10, true, undefined, currentPage);
        addText('Details', margin + 280, yPosition, 10, true, undefined, currentPage);
        addText('Amount', width - margin - 80, yPosition, 10, true, undefined, currentPage);
        yPosition -= 15;
        
        // Draw line
        currentPage.drawLine({
          start: { x: margin, y: yPosition },
          end: { x: width - margin, y: yPosition },
          thickness: 1,
          color: rgb(0, 0, 0)
        });
        yPosition -= 10;
        
        employeesForClient.forEach(item => {
          if (yPosition < 100) {
            currentPage = pdfDoc.addPage([612, 792]);
            yPosition = height - 50;
          }
          
          const breakdown = item.clientBreakdown?.find(b => b.clientId === uniqueKey);
          if (!breakdown) return;
          
          // Employee name
          addText(item.employee.name, margin, yPosition, 10, false, undefined, currentPage);
          
          // Pay type
          addText(breakdown.payType, margin + 200, yPosition, 10, false, undefined, currentPage);
          
          // Details (first detail only, or summary)
          if (breakdown.details && breakdown.details.length > 0) {
            const firstDetail = breakdown.details[0];
            addText(`${firstDetail.label}: ${firstDetail.value}`, margin + 280, yPosition, 9, false, undefined, currentPage);
            if (breakdown.details.length > 1) {
              addText(`+ ${breakdown.details.length - 1} more`, margin + 280, yPosition - 12, 8, false, undefined, currentPage);
            }
          }
          
          // Amount
          addText(`$${breakdown.amount.toFixed(2)}`, width - margin - 80, yPosition, 10, false, undefined, currentPage);
          
          yPosition -= 20;
        });
        
        // Subtotal
        yPosition -= 5;
        currentPage.drawLine({
          start: { x: margin, y: yPosition },
          end: { x: width - margin, y: yPosition },
          thickness: 1,
          color: rgb(0, 0, 0)
        });
        yPosition -= 10;
        
        const subtotal = employeesForClient.reduce((sum, item) => {
          const breakdown = item.clientBreakdown?.find(b => b.clientId === uniqueKey);
          return sum + (breakdown?.amount || 0);
        }, 0);
        
        addText(`Subtotal for ${displayName}`, margin, yPosition, 10, true, undefined, currentPage);
        addText(`$${subtotal.toFixed(2)}`, width - margin - 80, yPosition, 10, true, undefined, currentPage);
        yPosition -= sectionSpacing * 2;
      });
      
      // Generate PDF and download
      const pdfBytes = await pdfDoc.save();
      const blob = new Blob([pdfBytes as any], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `Payroll_Review_${companyName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
    } catch (error) {
      console.error('Error generating PDF:', error);
      alert('Error generating PDF. Please try again.');
    }
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Batch Checks
      </Typography>

      {!selectedCompanyId ? (
        <>

          
          <Typography variant="h5" gutterBottom sx={{ mb: 3, fontWeight: 'bold', color: 'text.primary' }}>
            Select a Company
          </Typography>
          
          <Box sx={{ 
            display: 'grid', 
            gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', 
            gap: 3,
            maxWidth: 1200
          }}>
            {companies.map((c) => (
              <Box
                key={c.id}
                sx={{
                  border: '2px solid',
                  borderColor: 'grey.200',
                  borderRadius: 3,
                  p: 3,
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  backgroundColor: 'white',
                  '&:hover': {
                    borderColor: 'primary.main',
                    backgroundColor: 'primary.50',
                    transform: 'translateY(-2px)',
                    boxShadow: 3
                  },
                  position: 'relative',
                  overflow: 'hidden'
                }}
                onClick={() => {
                  setSelectedCompanyId(c.id);
                  // Auto-select the first client of this company
                  const companyClients = clients.filter(client => client.companyIds?.includes(c.id));
                  if (companyClients.length > 0) {
                    setSelectedClientId(companyClients[0].id);
                  }
                }}
              >
                {/* Company Logo */}
                <Box sx={{ 
                  display: 'flex', 
                  justifyContent: 'center', 
                  mb: 2,
                  position: 'relative'
                }}>
                  {c.logoBase64 ? (
                    <Avatar
                      src={c.logoBase64}
                      sx={{ 
                        width: 80, 
                        height: 80,
                        border: '3px solid',
                        borderColor: 'grey.300'
                      }}
                    />
                  ) : (
                    <Avatar
                      sx={{ 
                        width: 80, 
                        height: 80,
                        backgroundColor: 'primary.main',
                        fontSize: '2rem',
                        border: '3px solid',
                        borderColor: 'grey.300'
                      }}
                    >
                      {c.name ? c.name[0].toUpperCase() : '?'}
                    </Avatar>
                  )}
                </Box>
                
                {/* Company Name */}
                <Typography 
                  variant="h6" 
                  sx={{ 
                    textAlign: 'center', 
                    fontWeight: 'bold',
                    color: 'text.primary',
                    mb: 1
                  }}
              >
                {c.name}
                </Typography>
                
                {/* Company Info */}
                <Box sx={{ textAlign: 'center' }}>
                  <Typography variant="body2" color="text.secondary">
                    Click to create checks for this company
                  </Typography>
                </Box>
                
                {/* Employee Count Badge */}
                <Box sx={{ 
                  position: 'absolute', 
                  top: 10, 
                  left: 10,
                  backgroundColor: 'secondary.main',
                  color: 'white',
                  borderRadius: '12px',
                  px: 1.5,
                  py: 0.5,
                  fontSize: '0.75rem',
                  fontWeight: 'bold'
                }}>
                  {employees.filter(emp => 
                    emp.companyId === c.id || 
                    (emp.companyIds && emp.companyIds.includes(c.id))
                  ).length} employees
                </Box>
              </Box>
            ))}
          </Box>
        </>
      ) : (
        <>
          {/* Company Header */}
          <Box sx={{ 
            mb: 3, 
            p: 3, 
            backgroundColor: 'grey.50', 
            borderRadius: 3,
            border: '1px solid',
            borderColor: 'grey.200',
            display: 'flex',
            alignItems: 'center',
            gap: 3
          }}>
            {(() => {
              const selectedCompany = companies.find(c => c.id === selectedCompanyId);
              return (
                <>
                  {selectedCompany?.logoBase64 ? (
                    <Avatar
                      src={selectedCompany.logoBase64}
                      sx={{ 
                        width: 60, 
                        height: 60,
                        border: '2px solid',
                        borderColor: 'primary.main'
                      }}
                    />
                  ) : (
                    <Avatar
                      sx={{ 
                        width: 60, 
                        height: 60,
                        backgroundColor: 'primary.main',
                        fontSize: '1.5rem',
                        border: '2px solid',
                        borderColor: 'primary.main'
                      }}
                    >
                      {selectedCompany?.name ? selectedCompany.name[0].toUpperCase() : '?'}
                    </Avatar>
                  )}
                  <Box sx={{ flex: 1 }}>
                    <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'primary.main' }}>
                      {selectedCompany?.name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Creating batch checks for employees
                    </Typography>
                  </Box>
          <Button
            variant="outlined"
            onClick={() => setSelectedCompanyId(null)}
                    sx={{
                      borderRadius: 2,
                      px: 3,
                      py: 1.5,
                      borderWidth: 2,
                      fontWeight: 'bold',
                      '&:hover': {
                        borderWidth: 2,
                        transform: 'translateY(-1px)',
                        boxShadow: 2
                      },
                      transition: 'all 0.2s ease'
                    }}
          >
            â† Back to Companies
          </Button>
          {/* Use Previous Batch Button - Only show for single clients */}
         
            <Button
              variant="outlined"
              onClick={usePreviousBatch}
              sx={{
                borderRadius: 2,
                px: 3,
                py: 1.5,
                borderWidth: 2,
                fontWeight: 'bold',
                ml: 2,
                borderColor: '#1976d2',
                color: '#1976d2',
                '&:hover': {
                  borderWidth: 2,
                  backgroundColor: '#1976d2',
                  color: 'white',
                  transform: 'translateY(-1px)',
                  boxShadow: 2
                },
                transition: 'all 0.2s ease'
              }}
            >
               Use Previous Batch
            </Button>
            
            {/* Continue Reviewing Button - Show if there's saved data */}
            {(() => {
              // Check if there's any saved data: either selected employees OR input data
              // First check in-memory state
              let hasSavedData = Object.keys(tabData).length > 0 && 
                Object.values(tabData).some(tab => {
                  // Check for selected employees
                  const hasSelectedEmployees = Object.keys(tab.selectedEmployees || {}).some(id => tab.selectedEmployees[id]);
                  // Check for input data (even if employee isn't "selected", they might have data)
                  const hasInputData = Object.keys(tab.inputs || {}).length > 0;
                  return hasSelectedEmployees || hasInputData;
                });
              
              // If no data in memory, check localStorage directly as fallback
              // This ensures the button shows even if state hasn't been restored yet
              if (!hasSavedData) {
                try {
                  const savedTabData = localStorage.getItem('batchChecks_tabData');
                  if (savedTabData) {
                    const parsed = JSON.parse(savedTabData);
                    hasSavedData = Object.keys(parsed).length > 0 && 
                      Object.values(parsed).some((tab: any) => {
                        const hasSelectedEmployees = Object.keys(tab.selectedEmployees || {}).some((id: string) => tab.selectedEmployees[id]);
                        const hasInputData = Object.keys(tab.inputs || {}).length > 0;
                        return hasSelectedEmployees || hasInputData;
                      });
                  }
                } catch (e) {
                  console.error('Error checking localStorage for saved data:', e);
                }
              }
              
              if (!hasSavedData) return null;
              
              return (
                <Button
                  variant="contained"
                  onClick={reviewChecks}
                  sx={{
                    borderRadius: 2,
                    px: 3,
                    py: 1.5,
                    fontWeight: 'bold',
                    ml: 2,
                    backgroundColor: '#4caf50',
                    color: 'white',
                    '&:hover': {
                      backgroundColor: '#45a049',
                      transform: 'translateY(-1px)',
                      boxShadow: 2
                    },
                    transition: 'all 0.2s ease'
                  }}
                >
                  ðŸ“‹ Continue Reviewing
                </Button>
              );
            })()}
        
          
                </>
              );
            })()}
          </Box>

          {/* Enhanced Client Selection with Tabs */}
          {clientsWithActiveEmployees.length > 0 && (
            <Box sx={{ mb: 3 }}>
              <Typography variant="h6" gutterBottom sx={{ mb: 2 }}>
                 Select Client for This Work
              </Typography>
              
              {/* Client Tabs */}
              <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
                <Tabs 
                  value={selectedClientId || clientsWithActiveEmployees[0]?.id || ''} 
                  onChange={(e: React.SyntheticEvent, newValue: string) => setSelectedClientId(newValue)}
                  variant="scrollable"
                  scrollButtons="auto"
                  sx={{ 
                    '& .MuiTab-root': { 
                      minHeight: '48px',
                      textTransform: 'none',
                      fontWeight: 'bold'
                    }
                  }}
                >
                  {/* Individual Client Tabs - Show ALL clients */}
                  {clientsWithActiveEmployees.map((client) => (
                    <Tab
                      key={client.id}
                      label={
                        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                          <span>{client.name}</span>
                          {client.division && (
                            <Typography variant="caption" color="primary" sx={{ fontSize: '0.7rem', fontWeight: 'bold' }}>
                              {client.division}
                            </Typography>
                          )}
                        </Box>
                      }
                      value={client.id}
                      sx={{ 
                        minWidth: '120px',
                        '&.Mui-selected': { 
                          backgroundColor: 'primary.light',
                          color: 'primary.contrastText',
                          borderRadius: '8px 8px 0 0'
                        }
                      }}
                    />
                  ))}
                </Tabs>
                      </Box>
              
            </Box>
          )}

          {/* Filter employees based on selected client tab */}
          {(() => {
            // Debug: Log current state
            console.log(`ðŸ” [Employee Filtering] selectedClientId: ${selectedClientId}, filteredEmployees.length: ${filteredEmployees.length}`);
            
            let employeesToShow = filteredEmployees;
            
            // Debug: Log employee data for key employees
            const domingo = filteredEmployees.find(emp => emp.name === 'Domingo Perez Lopez');
            if (domingo) {
              console.log('ðŸ” Domingo Perez Lopez data:', {
                id: domingo.id,
                name: domingo.name,
                clientId: domingo.clientId,
                payType: domingo.payType,
                clientPayTypeRelationships: domingo.clientPayTypeRelationships
              });
            }
            
            if (selectedClientId) {
              // Show ALL employees who work for this client (regardless of other relationships)
              const client = companyClients.find(c => c.id === selectedClientId);
              if (client) {
                console.log(`ðŸ” Filtering for client: ${client.name} (${client.id})`);
                console.log(`ðŸ” Total employees before filtering: ${filteredEmployees.length}`);
                
                if (client.name.toLowerCase().includes('per diem')) {
                  // Per Diem tab: show ALL employees with per diem relationships for this client
                  employeesToShow = filteredEmployees.filter(emp => {
                    // Check if employee has relationships with this client and per diem pay type
                    const hasPerDiemForThisClient = emp.clientPayTypeRelationships?.some(rel => 
                      rel.clientId === selectedClientId && rel.payType === 'perdiem' && rel.active
                    );
                    
                    // Check legacy fields - only count if employee has NO relationships
                    const hasLegacyPerDiem = emp.clientId === selectedClientId && emp.payType === 'perdiem';
                    const legacyEmployeeWithPerDiem = hasLegacyPerDiem && (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0);
                    
                    const shouldShow = hasPerDiemForThisClient || legacyEmployeeWithPerDiem;
                    if (emp.name === 'Domingo Perez Lopez') {
                      console.log(`ðŸ” Domingo: hasPerDiemForThisClient=${hasPerDiemForThisClient}, hasLegacyPerDiem=${hasLegacyPerDiem}, shouldShow=${shouldShow}`);
                    }
                    return shouldShow;
                  });
                } else if (client.name.toLowerCase().includes('hourly')) {
                  // Hourly tab: show ALL employees with hourly relationships for this client
                  employeesToShow = filteredEmployees.filter(emp => {
                    
                    // Check if employee has relationships with this client and hourly pay type
                    const hasHourlyForThisClient = emp.clientPayTypeRelationships?.some(rel => 
                      rel.clientId === selectedClientId && rel.payType === 'hourly' && rel.active
                    );
                    
                    // Check legacy fields - only count if employee has NO relationships
                    const hasLegacyHourly = emp.clientId === selectedClientId && emp.payType === 'hourly';
                    const legacyEmployeeWithHourly = hasLegacyHourly && (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0);
                    
                    const shouldShow = hasHourlyForThisClient || legacyEmployeeWithHourly;
                    if (emp.name === 'Domingo Perez Lopez') {
                      console.log(`ðŸ” Domingo: hasHourlyForThisClient=${hasHourlyForThisClient}, hasLegacyHourly=${hasLegacyHourly}, shouldShow=${shouldShow}`);
                    }
                    return shouldShow;
                  });
                } else {
                  // Other client tabs: show ALL employees for this specific client
                  employeesToShow = filteredEmployees.filter(emp => {
                    // Check if employee has any active relationship with this client
                    const hasActiveRelationshipWithThisClient = emp.clientPayTypeRelationships?.some(rel => 
                      rel.clientId === selectedClientId && rel.active
                    );
                    
                    // Check legacy fields - only count if employee has NO relationships
                    const hasLegacyClient = emp.clientId === selectedClientId;
                    const legacyEmployeeWithSingleClient = hasLegacyClient && (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0);
                    
                    const shouldShow = hasActiveRelationshipWithThisClient || legacyEmployeeWithSingleClient;
                    
                    return shouldShow;
                  });
                }
                
                console.log(`ðŸ” Employees after filtering: ${employeesToShow.length}`);
                console.log(`ðŸ” Employee names:`, employeesToShow.map(emp => emp.name));
              }
            }
            
            // Apply search filter
            if (employeeSearchTerm) {
              employeesToShow = employeesToShow.filter(emp => 
                emp.name.toLowerCase().includes(employeeSearchTerm.toLowerCase())
              );
            }
            
            // Always sort alphabetically by first name
            employeesToShow = employeesToShow.sort((a, b) => {
              const firstNameA = a.name.split(' ')[0].toLowerCase();
              const firstNameB = b.name.split(' ')[0].toLowerCase();
              return firstNameA.localeCompare(firstNameB);
            });
            
            const employeesWithData = employeesToShow.filter((emp: any) => {
              const data = inputs[emp.id];
              if (!data) return false;
              
              // Check legacy fields
              const hasLegacyHours = data.hours && parseFloat(data.hours) > 0;
              const hasLegacyPerDiem = data.perdiemAmount && parseFloat(data.perdiemAmount) > 0;
              const hasLegacyBreakdown = data.perdiemBreakdown && Object.values(data.perdiemBreakdown).some(val => parseFloat(val as string) > 0);
              
              // Check relationship-specific fields
              let hasRelationshipData = false;
              if (emp.clientPayTypeRelationships) {
                emp.clientPayTypeRelationships.forEach((rel: any) => {
                  const relId = rel.id;
                  const hasRelHours = data[`${relId}_hours`] && parseFloat(data[`${relId}_hours`]) > 0;
                  const hasRelOTHours = data[`${relId}_otHours`] && parseFloat(data[`${relId}_otHours`]) > 0;
                  const hasRelHolidayHours = data[`${relId}_holidayHours`] && parseFloat(data[`${relId}_holidayHours`]) > 0;
                  const hasRelPerDiemAmount = data[`${relId}_perdiemAmount`] && parseFloat(data[`${relId}_perdiemAmount`]) > 0;
                  
                  // Check Other Pay fields
                  const hasRelOtherPay = data[`${relId}_otherPay`] && Array.isArray(data[`${relId}_otherPay`]) && 
                    data[`${relId}_otherPay`].some((item: OtherPayItem) => parseFloat(item.amount) > 0);
                  
                  // Check daily breakdown fields
                  const dailyFields = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                  const hasRelDailyBreakdown = dailyFields.some(day => 
                    data[`${relId}_perdiem${day}`] && parseFloat(data[`${relId}_perdiem${day}`]) > 0
                  );
                  
                  if (hasRelHours || hasRelOTHours || hasRelHolidayHours || hasRelPerDiemAmount || hasRelDailyBreakdown || hasRelOtherPay) {
                    hasRelationshipData = true;
                  }
                });
              }
              
              return hasLegacyHours || hasLegacyPerDiem || hasLegacyBreakdown || hasRelationshipData;
            });
            
            console.log('ðŸ” DEBUG: employeesToShow.length:', employeesToShow.length);
            console.log('ðŸ” DEBUG: employeesWithData.length:', employeesWithData.length);
            console.log('ðŸ” DEBUG: employeesToShow names:', employeesToShow.map(emp => emp.name));
            return (
              <>

                {/* Master Date Picker - Populates all employee dates */}
                {Object.keys(selectedEmployees).filter(id => selectedEmployees[id]).length > 0 && (
                  <Paper sx={{ p: 2, mb: 2, bgcolor: '#e3f2fd' }} elevation={2}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                      <Typography variant="subtitle1" fontWeight="bold" sx={{ minWidth: 150 }}>
                        Default Check Date:
                      </Typography>
                      <TextField
                        type="date"
                        label="Apply to All Employees"
                        value={defaultCheckDate}
                        onClick={(e) => {
                          // Apply the current date to ALL employees across ALL tabs
                          if (defaultCheckDate) {
                            const dateValue = createLocalDate(defaultCheckDate);
                            
                            setTabData(prev => {
                              const updatedTabData = { ...prev };
                              
                              // Apply date to all tabs
                              Object.keys(updatedTabData).forEach(tabId => {
                                const tabInfo = updatedTabData[tabId];
                                const updatedInputs = { ...tabInfo.inputs };
                                
                                // Apply date to all employees in this tab that have inputs
                                Object.keys(updatedInputs).forEach(empId => {
                                  updatedInputs[empId] = {
                                    ...updatedInputs[empId],
                                    checkDate: dateValue
                                  };
                                });
                                
                                updatedTabData[tabId] = {
                                  ...tabInfo,
                                  inputs: updatedInputs
                                };
                              });
                              
                              return updatedTabData;
                            });
                          }
                        }}
                        onChange={(e) => {
                          if (e.target.value) {
                            // Update the default check date state
                            setDefaultCheckDate(e.target.value);
                            
                            // Apply this date to ALL employees across ALL tabs
                            const dateValue = createLocalDate(e.target.value);
                            
                            setTabData(prev => {
                              const updatedTabData = { ...prev };
                              
                              // Apply date to all tabs
                              Object.keys(updatedTabData).forEach(tabId => {
                                const tabInfo = updatedTabData[tabId];
                                const updatedInputs = { ...tabInfo.inputs };
                                
                                // Apply date to all employees in this tab that have inputs
                                Object.keys(updatedInputs).forEach(empId => {
                                  updatedInputs[empId] = {
                                    ...updatedInputs[empId],
                                    checkDate: dateValue
                                  };
                                });
                                
                                updatedTabData[tabId] = {
                                  ...tabInfo,
                                  inputs: updatedInputs
                                };
                              });
                              
                              return updatedTabData;
                            });
                          }
                        }}
                        InputLabelProps={{ shrink: true }}
                        helperText="Click or change this date to apply it to all employees across all tabs. New employees selected will automatically get this date."
                        sx={{ flex: 1 }}
                      />
                    </Box>
                  </Paper>
                )}

                {/* Employee Spreadsheet View - Show all selected employees in rows + always one empty row */}
                <Paper sx={{ p: 2 }} elevation={2}>
                  <TableContainer sx={{ maxHeight: '70vh', overflow: 'auto' }}>
                    <Table size="small" stickyHeader>
                      <TableHead>
                        <TableRow sx={{ backgroundColor: '#f5f5f5' }}>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 50, position: 'sticky', left: 0, zIndex: 3, backgroundColor: '#f5f5f5' }}>
                            <Checkbox
                              checked={(() => {
                                const selectedEmpIds = Object.keys(selectedEmployees).filter(id => selectedEmployees[id]);
                                return selectedEmpIds.length > 0 && selectedEmpIds.every(id => selectedEmployees[id]);
                              })()}
                              indeterminate={(() => {
                                const selectedEmpIds = Object.keys(selectedEmployees).filter(id => selectedEmployees[id]);
                                return selectedEmpIds.some(id => selectedEmployees[id]) && !selectedEmpIds.every(id => selectedEmployees[id]);
                              })()}
                              onChange={(e) => {
                                const selectedEmpIds = Object.keys(selectedEmployees).filter(id => selectedEmployees[id]);
                                const newSelected = e.target.checked;
                                const newSelectedEmployees = { ...selectedEmployees };
                                selectedEmpIds.forEach(empId => {
                                  newSelectedEmployees[empId] = newSelected;
                                });
                                setSelectedEmployees(newSelectedEmployees);
                              }}
                            />
                          </TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 200, position: 'sticky', left: 50, zIndex: 3, backgroundColor: '#f5f5f5' }}>Name</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 120 }}>Check Date</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 80 }}>Hours</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 80 }}>OT Hours</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 80 }}>Holiday Hours</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 100 }}>Per Diem</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 100 }}>Other Pay $</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 120 }}>Total Amount $</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 100 }}>Memo</TableCell>
                          <TableCell sx={{ fontWeight: 'bold', minWidth: 100 }}>Action</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {(() => {
                          const selectedEmpIds = Object.keys(selectedEmployees).filter(id => selectedEmployees[id]);
                          const rows: Array<{ empId: string | null; isNew: boolean }> = [];
                          
                          // Add all selected employees
                          selectedEmpIds.forEach(empId => {
                            rows.push({ empId, isNew: false });
                          });
                          
                          // Always add at least one empty row
                          rows.push({ empId: null, isNew: true });
                          
                          return rows.map((row, index) => {
                            const empId = row.empId;
                            const isNewRow = row.isNew;
                            
                            // For new/empty rows
                            if (isNewRow || !empId) {
                              return (
                                <TableRow 
                                  key={`new-row-${index}`}
                                  sx={{ 
                                    '&:hover': { backgroundColor: '#f5f5f5' },
                                    backgroundColor: '#fafafa'
                                  }}
                                >
                                  <TableCell sx={{ position: 'sticky', left: 0, zIndex: 2, backgroundColor: '#fafafa' }}>
                                    <Checkbox disabled />
                                  </TableCell>
                                  <TableCell sx={{ position: 'sticky', left: 50, zIndex: 2, backgroundColor: '#fafafa' }}>
                                    <FormControl size="small" fullWidth>
                                      <Select
                                        displayEmpty
                                        value=""
                                        onChange={(e) => {
                                          const selectedEmpId = e.target.value as string;
                                          if (selectedEmpId) {
                                            // Add the employee
                                            setSelectedEmployees(prev => ({ ...prev, [selectedEmpId]: true }));
                                            // Initialize input data with default date
                                            if (defaultCheckDate) {
                                              const dateValue = createLocalDate(defaultCheckDate);
                                              setInputs(prev => ({
                                                ...prev,
                                                [selectedEmpId]: {
                                                  ...prev[selectedEmpId],
                                                  checkDate: dateValue
                                                }
                                              }));
                                            }
                                            // Auto-select this employee tab
                                            setSelectedEmployeeTab(selectedEmpId);
                                          }
                                        }}
                                        onClick={(e) => e.stopPropagation()}
                                        sx={{ backgroundColor: 'white' }}
                                      >
                                        <MenuItem value="" disabled>
                                          <em>Select employee...</em>
                                        </MenuItem>
                                        {(employeesToShow || [])
                                          .filter((emp: Employee) => emp && emp.id && !selectedEmployees[emp.id])
                                          .map((emp: Employee) => (
                                            <MenuItem key={emp.id} value={emp.id}>
                                              {emp.name}
                                            </MenuItem>
                                          ))}
                                      </Select>
                                    </FormControl>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                  </TableCell>
                                </TableRow>
                              );
                            }
                            
                            // For existing employee rows
                            const emp = employees.find(e => e.id === empId);
                            if (!emp) return null;
                            
                            // Get relationship data for current client
                            const selectedRelationships = selectedClientId && emp.clientPayTypeRelationships
                                ?.filter((rel: any) => 
                                  inputs[empId]?.selectedRelationshipIds?.includes(rel.id) && 
                                  rel.clientId === selectedClientId
                                ) || [];
                              
                              const primaryRelationship = selectedRelationships[0];
                              const isHourly = primaryRelationship?.payType === 'hourly';
                              
                              // Calculate totals
                              let hours = 0;
                              let otHours = 0;
                              let holidayHours = 0;
                              let perDiemAmount = 0;
                              let otherPayTotal = 0;
                              
                              if (primaryRelationship) {
                                if (isHourly) {
                                  hours = parseFloat((inputs[empId] as any)?.[`${primaryRelationship.id}_hours`] || '0');
                                  otHours = parseFloat((inputs[empId] as any)?.[`${primaryRelationship.id}_otHours`] || '0');
                                  holidayHours = parseFloat((inputs[empId] as any)?.[`${primaryRelationship.id}_holidayHours`] || '0');
                                  const otherPay = (inputs[empId] as any)?.[`${primaryRelationship.id}_otherPay`] || [];
                                  otherPayTotal = otherPay.reduce((sum: number, item: OtherPayItem) => sum + parseFloat(item.amount || '0'), 0);
                                } else {
                                  const hasBreakdown = (inputs[empId] as any)?.[`${primaryRelationship.id}_perdiemBreakdown`];
                                  if (hasBreakdown) {
                                    perDiemAmount = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].reduce((sum, day) => {
                                      return sum + parseFloat((inputs[empId] as any)?.[`${primaryRelationship.id}_perdiem${day}`] || '0');
                                    }, 0);
                                  } else {
                                    perDiemAmount = parseFloat((inputs[empId] as any)?.[`${primaryRelationship.id}_perdiemAmount`] || '0');
                                  }
                                  const otherPay = (inputs[empId] as any)?.[`${primaryRelationship.id}_otherPay`] || [];
                                  otherPayTotal = otherPay.reduce((sum: number, item: OtherPayItem) => sum + parseFloat(item.amount || '0'), 0);
                                }
                              }
                              
                              const totalAmount = calculateAmount(emp, inputs[empId] || {});
                              const checkDate = inputs[empId]?.checkDate;
                              const dateValue = checkDate 
                                ? `${checkDate.getMonth() + 1}/${checkDate.getDate()}/${checkDate.getFullYear()}`
                                : (defaultCheckDate ? new Date(defaultCheckDate).toLocaleDateString() : '');
                              
                              return (
                                <TableRow 
                                  key={empId}
                                  sx={{ 
                                    '&:hover': { backgroundColor: '#f5f5f5' },
                                    backgroundColor: selectedEmployeeTab === empId ? '#e3f2fd' : 'white'
                                  }}
                                  onClick={() => setSelectedEmployeeTab(empId)}
                                >
                                  <TableCell sx={{ position: 'sticky', left: 0, zIndex: 2, backgroundColor: selectedEmployeeTab === empId ? '#e3f2fd' : 'white' }}>
                                    <Checkbox
                                      checked={!!selectedEmployees[empId]}
                                      onChange={(e) => {
                                        e.stopPropagation();
                                        setSelectedEmployees(prev => ({ ...prev, [empId]: e.target.checked }));
                                        if (!e.target.checked) {
                                          setInputs(prev => {
                                            const { [empId]: removed, ...rest } = prev;
                                            return rest;
                                          });
                                          if (selectedEmployeeTab === empId) {
                                            const remaining = selectedEmpIds.filter(id => id !== empId && selectedEmployees[id]);
                                            setSelectedEmployeeTab(remaining.length > 0 ? remaining[0] : null);
                                          }
                                        }
                                      }}
                                    />
                                  </TableCell>
                                  <TableCell sx={{ fontWeight: 'bold', position: 'sticky', left: 50, zIndex: 2, backgroundColor: selectedEmployeeTab === empId ? '#e3f2fd' : 'white' }}>
                                    <FormControl size="small" fullWidth>
                                      <Select
                                        value={empId}
                                        onChange={(e) => {
                                          const newEmpId = e.target.value as string;
                                          if (newEmpId && newEmpId !== empId) {
                                            // Remove old employee
                                            setSelectedEmployees(prev => {
                                              const updated = { ...prev };
                                              updated[empId] = false;
                                              return updated;
                                            });
                                            setInputs(prev => {
                                              const { [empId]: removed, ...rest } = prev;
                                              return rest;
                                            });
                                            
                                            // Add new employee
                                            setSelectedEmployees(prev => ({ ...prev, [newEmpId]: true }));
                                            // Initialize input data with default date
                                            if (defaultCheckDate) {
                                              const dateValue = createLocalDate(defaultCheckDate);
                                              setInputs(prev => ({
                                                ...prev,
                                                [newEmpId]: {
                                                  ...prev[newEmpId],
                                                  checkDate: dateValue
                                                }
                                              }));
                                            }
                                            // Update selected tab if needed
                                            if (selectedEmployeeTab === empId) {
                                              setSelectedEmployeeTab(newEmpId);
                                            }
                                          }
                                        }}
                                        onClick={(e) => e.stopPropagation()}
                                        sx={{ backgroundColor: 'white' }}
                                      >
                                        {(employeesToShow || [])
                                          .filter((e: Employee) => e && e.id && (!selectedEmployees[e.id] || e.id === empId))
                                          .map((e: Employee) => (
                                            <MenuItem key={e.id} value={e.id}>
                                              {e.name}
                                            </MenuItem>
                                          ))}
                                      </Select>
                                    </FormControl>
                                  </TableCell>
                                  <TableCell>
                                    <TextField
                                      type="date"
                                      size="small"
                                      value={checkDate 
                                        ? `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}-${String(checkDate.getDate()).padStart(2, '0')}`
                                        : defaultCheckDate || ''}
                                      onChange={(e) => {
                                        if (e.target.value) {
                                          const dateValue = createLocalDate(e.target.value);
                                          handleInputChange(empId, "checkDate", dateValue);
                                        } else {
                                          handleInputChange(empId, "checkDate", null);
                                        }
                                      }}
                                      onClick={(e) => e.stopPropagation()}
                                      InputLabelProps={{ shrink: true }}
                                      sx={{ width: 150 }}
                                    />
                                  </TableCell>
                                  <TableCell>
                                    {isHourly ? (
                                      <TextField
                                        type="number"
                                        size="small"
                                        value={(inputs[empId] as any)?.[`${primaryRelationship.id}_hours`] || ""}
                                        onChange={(e) => (handleInputChange as any)(empId, `${primaryRelationship.id}_hours`, e.target.value)}
                                        onClick={(e) => e.stopPropagation()}
                                        sx={{ width: 80 }}
                                      />
                                    ) : (
                                      <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                    )}
                                  </TableCell>
                                  <TableCell>
                                    {isHourly ? (
                                      <TextField
                                        type="number"
                                        size="small"
                                        value={(inputs[empId] as any)?.[`${primaryRelationship.id}_otHours`] || ""}
                                        onChange={(e) => (handleInputChange as any)(empId, `${primaryRelationship.id}_otHours`, e.target.value)}
                                        onClick={(e) => e.stopPropagation()}
                                        sx={{ width: 80 }}
                                      />
                                    ) : (
                                      <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                    )}
                                  </TableCell>
                                  <TableCell>
                                    {isHourly ? (
                                      <TextField
                                        type="number"
                                        size="small"
                                        value={(inputs[empId] as any)?.[`${primaryRelationship.id}_holidayHours`] || ""}
                                        onChange={(e) => (handleInputChange as any)(empId, `${primaryRelationship.id}_holidayHours`, e.target.value)}
                                        onClick={(e) => e.stopPropagation()}
                                        sx={{ width: 80 }}
                                      />
                                    ) : (
                                      <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                    )}
                                  </TableCell>
                                  <TableCell>
                                    {!isHourly ? (
                                      <TextField
                                        type="number"
                                        size="small"
                                        value={(inputs[empId] as any)?.[`${primaryRelationship.id}_perdiemAmount`] || ""}
                                        onChange={(e) => (handleInputChange as any)(empId, `${primaryRelationship.id}_perdiemAmount`, e.target.value)}
                                        onClick={(e) => e.stopPropagation()}
                                        sx={{ width: 100 }}
                                      />
                                    ) : (
                                      <Typography variant="body2" sx={{ color: 'text.disabled' }}>-</Typography>
                                    )}
                                  </TableCell>
                                  <TableCell>
                                    <Button
                                      size="small"
                                      variant="outlined"
                                      startIcon={<AddIcon />}
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        setOtherPayDialogOpen(empId);
                                      }}
                                      sx={{ 
                                        minWidth: 120,
                                        justifyContent: 'flex-start',
                                        textTransform: 'none'
                                      }}
                                    >
                                      {otherPayTotal > 0 ? `$${otherPayTotal.toFixed(2)}` : '+ Add Pay'}
                                    </Button>
                                  </TableCell>
                                  <TableCell sx={{ fontWeight: 'bold', color: 'primary.main' }}>
                                    ${totalAmount}
                                  </TableCell>
                                  <TableCell>
                                    <TextField
                                      size="small"
                                      value={inputs[empId]?.memo || ""}
                                      onChange={(e) => handleInputChange(empId, "memo", e.target.value)}
                                      onClick={(e) => e.stopPropagation()}
                                      placeholder="Memo"
                                      sx={{ width: 100 }}
                                    />
                                  </TableCell>
                                  <TableCell>
                                    <Button
                                      size="small"
                                      variant="outlined"
                                      color="error"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        setSelectedEmployees(prev => ({ ...prev, [empId]: false }));
                                        setInputs(prev => {
                                          const { [empId]: removed, ...rest } = prev;
                                          return rest;
                                        });
                                        const remaining = Object.keys(selectedEmployees).filter(id => id !== empId && selectedEmployees[id]);
                                        setSelectedEmployeeTab(remaining.length > 0 ? remaining[0] : null);
                                      }}
                                    >
                                      Remove
                                    </Button>
                                  </TableCell>
                                </TableRow>
                              );
                            });
                          })()}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Paper>

                {/* Other Pay Dialog */}
                {otherPayDialogOpen && (() => {
                  const empId = otherPayDialogOpen;
                  const emp = employees.find(e => e.id === empId);
                  if (!emp) return null;
                  
                  // Get relationship for current client
                  const selectedRelationships = selectedClientId && emp.clientPayTypeRelationships
                    ?.filter((rel: any) => 
                      inputs[empId]?.selectedRelationshipIds?.includes(rel.id) && 
                      rel.clientId === selectedClientId
                    ) || [];
                  
                  const primaryRelationship = selectedRelationships[0];
                  if (!primaryRelationship) return null;
                  
                  const otherPayKey = `${primaryRelationship.id}_otherPay`;
                  const currentOtherPay = (inputs[empId] as any)?.[otherPayKey] || [];
                  
                  return (
                    <Dialog
                      open={true}
                      onClose={() => setOtherPayDialogOpen(null)}
                      maxWidth="sm"
                      fullWidth
                    >
                      <DialogTitle>
                        Other Pay - {emp.name}
                        <Typography variant="caption" sx={{ display: 'block', color: 'text.secondary', mt: 0.5 }}>
                          {(() => {
                            const client = clients.find(c => c.id === primaryRelationship.clientId);
                            return client?.name || primaryRelationship.clientName;
                          })()} - {primaryRelationship.payType === 'hourly' ? 'Hourly' : 'Per Diem'}
                        </Typography>
                      </DialogTitle>
                      <DialogContent>
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
                          {currentOtherPay.map((item: OtherPayItem, index: number) => (
                            <Box key={item.id} sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                              <TextField
                                label="Description"
                                size="small"
                                fullWidth
                                value={item.description}
                                onChange={(e) => {
                                  const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                    payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                  );
                                  handleInputChange(empId, otherPayKey, updatedOtherPay);
                                }}
                              />
                              <TextField
                                label="Amount"
                                type="number"
                                size="small"
                                value={item.amount}
                                onChange={(e) => {
                                  const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                    payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                  );
                                  handleInputChange(empId, otherPayKey, updatedOtherPay);
                                }}
                                sx={{ width: 150 }}
                              />
                              <IconButton
                                size="small"
                                color="error"
                                onClick={() => {
                                  const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                  handleInputChange(empId, otherPayKey, updatedOtherPay);
                                }}
                              >
                                <DeleteIcon />
                              </IconButton>
                            </Box>
                          ))}
                          
                          {currentOtherPay.length === 0 && (
                            <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', py: 2 }}>
                              No other pay items added yet
                            </Typography>
                          )}
                          
                          <Button
                            variant="outlined"
                            startIcon={<AddIcon />}
                            onClick={() => {
                              const newOtherPayItem = {
                                id: Date.now().toString(),
                                description: '',
                                amount: ''
                              };
                              handleInputChange(empId, otherPayKey, [...currentOtherPay, newOtherPayItem]);
                            }}
                            sx={{ mt: 1 }}
                          >
                            Add Other Pay Item
                          </Button>
                          
                          {currentOtherPay.length > 0 && (
                            <Box sx={{ mt: 2, p: 2, backgroundColor: '#f5f5f5', borderRadius: 1 }}>
                              <Typography variant="subtitle2" fontWeight="bold">
                                Total Other Pay: ${currentOtherPay.reduce((sum: number, item: OtherPayItem) => 
                                  sum + parseFloat(item.amount || '0'), 0
                                ).toFixed(2)}
                              </Typography>
                            </Box>
                          )}
                        </Box>
                      </DialogContent>
                      <DialogActions>
                        <Button onClick={() => setOtherPayDialogOpen(null)}>
                          Close
                        </Button>
                      </DialogActions>
                    </Dialog>
                  );
                })()}
                
{/* Review Checks Button */} 
                                justifyContent: 'space-between', 
                                alignItems: 'center', 
                                mb: 1,
                                p: 0.5,
                                backgroundColor: isHourly ? '#e3f2fd' : '#fff8e1',
                                borderRadius: 0.5
                              }}>
                                <Typography variant="subtitle2" fontWeight="bold" sx={{ 
                                  color: isHourly ? '#1976d2' : '#f57c00',
                                  display: 'flex',
                                  alignItems: 'center',
                                  gap: 0.5
                                }}>
                                  {(() => {
                                    const client = clients.find(c => c.id === relationship.clientId);
                                    return client ? client.name : relationship.clientName;
                                  })()} - {relationship.payType === 'hourly' ? 'Hourly' : 'Per Diem'}
                                </Typography>
                                <Button
                                  size="small"
                                  variant="outlined"
                                  color="error"
                                  onClick={() => {
                                    // Remove this relationship from selection
                                    const currentIds = inputs[emp.id]?.selectedRelationshipIds || [];
                                    const newIds = currentIds.filter(id => id !== relationship.id);
                                    handleInputChange(emp.id, "selectedRelationshipIds", newIds);
                                  }}
                                  sx={{ minWidth: 'auto', p: 0.5 }}
                                >
                                  âœ•
                                </Button>
                              </Box>

                              {/* Hourly Payment Fields */}
                              {isHourly && (
                                <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mb: 1 }}>
                                  <TextField
                                    label="Hours"
                                    type="number"
                                    value={(inputs[emp.id] as any)?.[`${relationship.id}_hours`] || ""}
                                    onChange={(e) =>
                                      (handleInputChange as any)(emp.id, `${relationship.id}_hours`, e.target.value)
                                    }
                                    sx={{ width: 140 }}
                                    size="small"
                                  />
                                  <TextField
                                    label="OT Hours"
                                    type="number"
                                    value={(inputs[emp.id] as any)?.[`${relationship.id}_otHours`] || ""}
                                    onChange={(e) =>
                                      (handleInputChange as any)(emp.id, `${relationship.id}_otHours`, e.target.value)
                                    }
                                    sx={{ width: 140 }}
                                    size="small"
                                  />
                                  <TextField
                                    label="Holiday Hours"
                                    type="number"
                                    value={(inputs[emp.id] as any)?.[`${relationship.id}_holidayHours`] || ""}
                                    onChange={(e) =>
                                      (handleInputChange as any)(emp.id, `${relationship.id}_holidayHours`, e.target.value)
                                    }
                                    sx={{ width: 140 }}
                                    size="small"
                                  />
                                </Box>
                              )}
                              
                              {/* Other Pay Section - Only show for hourly relationships */}
                              {relationship.payType === 'hourly' && (
                                <Box sx={{ mt: 1, mb: 1 }}>
                                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                                    <Typography variant="subtitle2" fontWeight="bold" sx={{ color: '#1976d2' }}>
                                      Other Pay
                                    </Typography>
                                    <Button
                                      size="small"
                                      variant="outlined"
                                      startIcon={<AddIcon />}
                                      onClick={() => {
                                        const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                        const newOtherPayItem = {
                                          id: Date.now().toString(),
                                          description: '',
                                          amount: ''
                                        };
                                        handleInputChange(emp.id, `${relationship.id}_otherPay`, [...currentOtherPay, newOtherPayItem]);
                                      }}
                                      sx={{ fontSize: '0.7rem', py: 0.5 }}
                                    >
                                      Add Other Pay
                                    </Button>
                                  </Box>
                                  
                                  {((inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || []).map((item: OtherPayItem, index: number) => (
                                    <Box key={item.id} sx={{ display: 'flex', gap: 1, mb: 1, alignItems: 'center' }}>
                                      <TextField
                                        label="Description"
                                        value={item.description}
                                        onChange={(e) => {
                                          const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                          const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                            payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                          );
                                          handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                        }}
                                        sx={{ flex: 2 }}
                                        size="small"
                                      />
                                      <TextField
                                        label="Amount"
                                        type="number"
                                        value={item.amount}
                                        onChange={(e) => {
                                          const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                          const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                            payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                          );
                                          handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                        }}
                                        sx={{ width: 100 }}
                                        size="small"
                                      />
                                      <IconButton
                                        size="small"
                                        color="error"
                                        onClick={() => {
                                          const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                          const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                          handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                        }}
                                      >
                                        <DeleteIcon />
                                      </IconButton>
                                    </Box>
                                  ))}
                                </Box>
                              )}

                              {/* Per Diem Payment Fields */}
                              {isPerDiem && (
                                <>
                                  {/* Per Diem Type Selection */}
                                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 1 }}>
                                    <Typography variant="body2" color="#f57c00">
                                      Payment Type:
                                    </Typography>
                                    <Box sx={{ display: 'flex', gap: 1 }}>
                                      <Button
                                        size="small"
                                        variant={(inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? "outlined" : "contained"}
                                        onClick={() => (handleInputChange as any)(emp.id, `${relationship.id}_perdiemBreakdown`, false)}
                                        sx={{ 
                                          backgroundColor: (inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? 'transparent' : '#f57c00',
                                          color: (inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? '#f57c00' : 'white',
                                          borderColor: '#f57c00',
                                          '&:hover': {
                                            backgroundColor: (inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? 'transparent' : '#e65100',
                                          }
                                        }}
                                      >
                                        Full Amount
                                      </Button>
                                      <Button
                                        size="small"
                                        variant={(inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? "contained" : "outlined"}
                                        onClick={() => (handleInputChange as any)(emp.id, `${relationship.id}_perdiemBreakdown`, true)}
                                        sx={{ 
                                          backgroundColor: (inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? '#f57c00' : 'transparent',
                                          color: (inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? 'white' : '#f57c00',
                                          borderColor: '#f57c00',
                                          '&:hover': {
                                            backgroundColor: (inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] ? '#e65100' : 'transparent',
                                          }
                                        }}
                                      >
                                        Breakdown
                                      </Button>
                                    </Box>
                                  </Box>
                                  
                                  {/* Per Diem Amount Input - Only show when FULL AMOUNT is selected */}
                                  {!(inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] && (
                                    <TextField
                                      label="Amount"
                                      type="number"
                                      value={(inputs[emp.id] as any)?.[`${relationship.id}_perdiemAmount`] || ""}
                                      onChange={(e) =>
                                        (handleInputChange as any)(emp.id, `${relationship.id}_perdiemAmount`, e.target.value)
                                      }
                                      sx={{ width: 140, mb: 1 }}
                                      size="small"
                                    />
                                  )}
                                  
                                  {/* Per Diem Breakdown Fields - Only show when BREAKDOWN is selected */}
                                  {(inputs[emp.id] as any)?.[`${relationship.id}_perdiemBreakdown`] && (
                                    <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mb: 1 }}>
                                      {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(day => (
                                        <TextField
                                          key={day}
                                          label={day}
                                          type="number"
                                          value={(inputs[emp.id] as any)?.[`${relationship.id}_perdiem${day}`] || ""}
                                          onChange={(e) =>
                                            (handleInputChange as any)(emp.id, `${relationship.id}_perdiem${day}`, e.target.value)
                                          }
                                          sx={{ width: 120 }}
                                          size="small"
                                        />
                                      ))}
                                    </Box>
                                  )}
                                  
                                  {/* Other Pay Section for Per Diem */}
                                  <Box sx={{ mt: 1, mb: 1 }}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                                      <Typography variant="subtitle2" fontWeight="bold" sx={{ color: '#f57c00' }}>
                                        Other Pay
                                      </Typography>
                                      <Button
                                        size="small"
                                        variant="outlined"
                                        startIcon={<AddIcon />}
                                        onClick={() => {
                                          const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                          const newOtherPayItem = {
                                            id: Date.now().toString(),
                                            description: '',
                                            amount: ''
                                          };
                                          handleInputChange(emp.id, `${relationship.id}_otherPay`, [...currentOtherPay, newOtherPayItem]);
                                        }}
                                        sx={{ fontSize: '0.7rem', py: 0.5 }}
                                      >
                                        Add Other Pay
                                      </Button>
                                    </Box>
                                    
                                    {((inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || []).map((item: OtherPayItem, index: number) => (
                                      <Box key={item.id} sx={{ display: 'flex', gap: 1, mb: 1, alignItems: 'center' }}>
                                        <TextField
                                          label="Description"
                                          value={item.description}
                                          onChange={(e) => {
                                            const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                            const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                              payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                            );
                                            handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                          }}
                                          sx={{ flex: 2 }}
                                          size="small"
                                        />
                                        <TextField
                                          label="Amount"
                                          type="number"
                                          value={item.amount}
                                          onChange={(e) => {
                                            const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                            const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                              payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                            );
                                            handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                          }}
                                          sx={{ width: 100 }}
                                          size="small"
                                        />
                                        <IconButton
                                          size="small"
                                          color="error"
                                          onClick={() => {
                                            const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                            const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                            handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                          }}
                                        >
                                          <DeleteIcon />
                                        </IconButton>
                                      </Box>
                                    ))}
                                  </Box>
                                </>
                              )}

                              {/* Calculation Breakdown */}
                              {/* Calculation Breakdown - Above Total */}
                              <Box sx={{ 
                                mb: 0.5, 
                                p: 0.75, 
                                backgroundColor: isHourly ? '#e3f2fd' : '#fff8e1',
                                borderRadius: 1,
                                fontSize: '0.7rem',
                                textAlign: 'center',
                                color: isHourly ? '#1976d2' : '#f57c00'
                              }}>
                                {isHourly ? (
                                  // Hourly breakdown
                                  (() => {
                                    const hours = parseFloat((inputs[emp.id] as any)?.[`${relationship.id}_hours`] || '0');
                                    const otHours = parseFloat((inputs[emp.id] as any)?.[`${relationship.id}_otHours`] || '0');
                                    const holidayHours = parseFloat((inputs[emp.id] as any)?.[`${relationship.id}_holidayHours`] || '0');
                                    const rate = getRelationshipPayRate(emp, relationship.id);
                                    const breakdown = [];
                                    
                                    if (hours > 0) breakdown.push(`${hours}hrs Ã— $${rate} = $${(hours * rate).toFixed(2)}`);
                                    if (otHours > 0) breakdown.push(`${otHours}OT Ã— $${(rate * 1.5).toFixed(2)} = $${(otHours * rate * 1.5).toFixed(2)}`);
                                    if (holidayHours > 0) breakdown.push(`${holidayHours}holiday Ã— $${(rate * 2).toFixed(2)} = $${(holidayHours * rate * 2).toFixed(2)}`);
                                    
                                    return breakdown.length > 0 ? breakdown.join(' + ') : 'No hours entered';
                                  })()
                                ) : (
                                  // Per diem breakdown
                                  (() => {
                                    // Check if any daily amounts are entered
                                    const dailyTotals: number[] = [];
                                    ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].forEach(day => {
                                      const dayValue = parseFloat((inputs[emp.id] as any)[`${relationship.id}_perdiem${day}`] || '0');
                                      if (dayValue > 0) dailyTotals.push(dayValue);
                                    });
                                    
                                    let perDiemAmount = 0;
                                    if (dailyTotals.length > 0) {
                                      // Daily breakdown mode - use daily amounts
                                      perDiemAmount = dailyTotals.reduce((sum, val) => sum + val, 0);
                                    } else {
                                      // Full amount mode - use single amount
                                      perDiemAmount = parseFloat((inputs[emp.id] as any)[`${relationship.id}_perdiemAmount`] || '0');
                                    }
                                    
                                    // Add Other Pay amounts for this relationship
                                    const otherPayTotal = ((inputs[emp.id] as any)[`${relationship.id}_otherPay`] || []).reduce((sum: number, item: OtherPayItem) => sum + (parseFloat(item.amount) || 0), 0);
                                    
                                    if (perDiemAmount > 0 || otherPayTotal > 0) {
                                      const total = perDiemAmount + otherPayTotal;
                                      const breakdown = [];
                                      if (perDiemAmount > 0) {
                                        breakdown.push(dailyTotals.length > 0 ? `$${perDiemAmount.toFixed(2)} (${dailyTotals.length} days)` : `$${perDiemAmount.toFixed(2)}`);
                                      }
                                      if (otherPayTotal > 0) {
                                        breakdown.push(`Other Pay: $${otherPayTotal.toFixed(2)}`);
                                      }
                                      return breakdown.join(' + ');
                                    }
                                    return 'No amount entered';
                                  })()
                                )}
                              </Box>
                              
                              {/* Payment Total for this relationship */}
                              <Box sx={{ 
                                display: 'flex', 
                                justifyContent: 'space-between', 
                                mt: 0.5, 
                                p: 0.75, 
                                backgroundColor: isHourly ? '#e3f2fd' : '#fff8e1', 
                                borderRadius: 1 
                              }}>
                                <Typography variant="body2" fontWeight="bold" sx={{ color: isHourly ? '#1976d2' : '#f57c00' }}>
                                  {isHourly ? 'Hourly' : 'Per Diem'} Total:
                                </Typography>
                                <Typography variant="body2" fontWeight="bold" sx={{ color: isHourly ? '#1976d2' : '#f57c00' }}>
                                  ${isHourly 
                                    ? calculateHourlyTotalForRelationship(emp, inputs[emp.id] || {}, relationship.id)
                                    : calculatePerDiemTotalForRelationship(inputs[emp.id] || {}, relationship.id)
                                  }
                                </Typography>
                              </Box>
                            </Box>
                          );
                        });
                  })()}
                    </>
                  )}

                  {/* Legacy Single Client Support - Keep for backward compatibility */}
                  {/* Only show legacy sections if employee has NO relationships and none selected in inputs */}
                  {(() => {
                    console.log(`ðŸ” [Legacy Gate] ${emp.name}:`, {
                      selectedClientId,
                      hasRelationships: !!(emp.clientPayTypeRelationships && emp.clientPayTypeRelationships.length > 0),
                      relationshipsCount: emp.clientPayTypeRelationships?.length || 0,
                      selectedRelationshipIds: inputs[emp.id]?.selectedRelationshipIds,
                      selectedRelationshipIdsLength: inputs[emp.id]?.selectedRelationshipIds?.length || 0,
                      shouldShowLegacy: selectedClientId !== 'multiple' &&
                        (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0) &&
                        !(((inputs[emp.id]?.selectedRelationshipIds?.length) ?? 0) > 0)
                    });
                    return null;
                  })()}
                  {selectedClientId !== 'multiple' &&
                    (!emp.clientPayTypeRelationships || emp.clientPayTypeRelationships.length === 0) &&
                    !(((inputs[emp.id]?.selectedRelationshipIds?.length) ?? 0) > 0) && (
                    <>
                      {/* Hourly Section - Show on hourly clients */}
                      {(() => {
                        console.log(`ðŸ” [Legacy Hourly Check] ${emp.name}:`, {
                          selectedClientId,
                          payTypes: emp.payTypes,
                          includesHourly: emp.payTypes?.includes('hourly'),
                          willShowHourly: selectedClientId && emp.payTypes?.includes('hourly')
                        });
                        return null;
                      })()}
                      {selectedClientId && emp.payTypes?.includes('hourly') && (
                    <Box sx={{ 
                      p: 1.5, 
                      mb: 1.5, 
                      backgroundColor: '#f0f8ff', 
                      borderRadius: 1, 
                      border: '1px solid #b3d9ff',
                      width: '100%'
                    }}>
                      <Typography variant="subtitle2" fontWeight="bold" sx={{ mb: 0.5, color: '#1976d2' }}>
                        Hourly Payment
                      </Typography>
                      <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mb: 1 }}>
                  <TextField
                    label="Hours"
                    type="number"
                    value={(() => {
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          return inputs[emp.id]?.[`${relationship.id}_hours`] || "";
                        }
                      }
                      return inputs[emp.id]?.hours || "";
                    })()}
                    onChange={(e) => {
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          handleInputChange(emp.id, `${relationship.id}_hours`, e.target.value);
                          return;
                        }
                      }
                      handleInputChange(emp.id, "hours", e.target.value);
                    }}
                    sx={{ width: 140 }}
                    size="small"
                  />
                  <TextField
                    label="OT Hours"
                    type="number"
                    value={(() => {
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          return inputs[emp.id]?.[`${relationship.id}_otHours`] || "";
                        }
                      }
                      return inputs[emp.id]?.otHours || "";
                    })()}
                    onChange={(e) => {
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          handleInputChange(emp.id, `${relationship.id}_otHours`, e.target.value);
                          return;
                        }
                      }
                      handleInputChange(emp.id, "otHours", e.target.value);
                    }}
                    sx={{ width: 140 }}
                    size="small"
                  />
                  <TextField
                    label="Holiday Hours"
                    type="number"
                    value={(() => {
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          return inputs[emp.id]?.[`${relationship.id}_holidayHours`] || "";
                        }
                      }
                      return inputs[emp.id]?.holidayHours || "";
                    })()}
                    onChange={(e) => {
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          handleInputChange(emp.id, `${relationship.id}_holidayHours`, e.target.value);
                          return;
                        }
                      }
                      handleInputChange(emp.id, "holidayHours", e.target.value);
                    }}
                    sx={{ width: 140 }}
                    size="small"
                  />
                      </Box>
                      
                      {/* Other Pay Section for Legacy */}
                      <Box sx={{ mt: 1, mb: 1 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                          <Typography variant="subtitle2" fontWeight="bold" sx={{ color: '#1976d2' }}>
                            Other Pay
                          </Typography>
                          <Button
                            size="small"
                            variant="outlined"
                            startIcon={<AddIcon />}
                            onClick={() => {
                              // Check if employee has relationships and we're on a single client tab
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  // Use relationship-specific field
                                  const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                  const newOtherPayItem = {
                                    id: Date.now().toString(),
                                    description: '',
                                    amount: ''
                                  };
                                  handleInputChange(emp.id, `${relationship.id}_otherPay`, [...currentOtherPay, newOtherPayItem]);
                                  return;
                                }
                              }
                              // Fallback to legacy field
                              const currentOtherPay = inputs[emp.id]?.otherPay || [];
                              const newOtherPayItem = {
                                id: Date.now().toString(),
                                description: '',
                                amount: ''
                              };
                              handleInputChange(emp.id, "otherPay", [...currentOtherPay, newOtherPayItem]);
                            }}
                            sx={{ fontSize: '0.7rem', py: 0.5 }}
                          >
                            Add Other Pay
                          </Button>
                        </Box>
                        
                        {(() => {
                          // Check if employee has relationships and we're on a single client tab
                          if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                            const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                            if (relationship) {
                              // Use relationship-specific field
                              return ((inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || []).map((item: OtherPayItem, index: number) => (
                                <Box key={item.id} sx={{ display: 'flex', gap: 1, mb: 1, alignItems: 'center' }}>
                                  <TextField
                                    label="Description"
                                    value={item.description}
                                    onChange={(e) => {
                                      const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                      const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                        payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                      );
                                      handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                    }}
                                    sx={{ flex: 2 }}
                                    size="small"
                                  />
                                  <TextField
                                    label="Amount"
                                    type="number"
                                    value={item.amount}
                                    onChange={(e) => {
                                      const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                      const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                        payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                      );
                                      handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                    }}
                                    sx={{ width: 100 }}
                                    size="small"
                                  />
                                  <IconButton
                                    size="small"
                                    color="error"
                                    onClick={() => {
                                      const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                      const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                      handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                    }}
                                  >
                                    <DeleteIcon />
                                  </IconButton>
                                </Box>
                              ));
                            }
                          }
                          // Fallback to legacy field
                          return (inputs[emp.id]?.otherPay || []).map((item: OtherPayItem, index: number) => (
                            <Box key={item.id} sx={{ display: 'flex', gap: 1, mb: 1, alignItems: 'center' }}>
                              <TextField
                                label="Description"
                                value={item.description}
                                onChange={(e) => {
                                  const currentOtherPay = inputs[emp.id]?.otherPay || [];
                                  const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                    payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                  );
                                  handleInputChange(emp.id, "otherPay", updatedOtherPay);
                                }}
                                sx={{ flex: 2 }}
                                size="small"
                              />
                              <TextField
                                label="Amount"
                                type="number"
                                value={item.amount}
                                onChange={(e) => {
                                  const currentOtherPay = inputs[emp.id]?.otherPay || [];
                                  const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                    payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                  );
                                  handleInputChange(emp.id, "otherPay", updatedOtherPay);
                                }}
                                sx={{ width: 100 }}
                                size="small"
                              />
                              <IconButton
                                size="small"
                                color="error"
                                onClick={() => {
                                  const currentOtherPay = inputs[emp.id]?.otherPay || [];
                                  const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                  handleInputChange(emp.id, "otherPay", updatedOtherPay);
                                }}
                              >
                                <DeleteIcon />
                              </IconButton>
                            </Box>
                          ));
                        })()}
                      </Box>
                      
                      {/* âœ… Hourly Total */}
                      {/* Calculation Breakdown - Above Total */}
                      <Box sx={{ 
                        mb: 0.5, 
                        p: 0.75, 
                        backgroundColor: '#e3f2fd',
                        borderRadius: 1,
                        fontSize: '0.7rem',
                        textAlign: 'center',
                        color: '#1976d2'
                      }}>
                        {(() => {
                          // If employee has relationships and we're on a single client tab, use relationship-specific data
                          if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                            const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                            if (relationship) {
                              const hours = parseFloat(inputs[emp.id]?.[`${relationship.id}_hours`] || '0');
                              const otHours = parseFloat(inputs[emp.id]?.[`${relationship.id}_otHours`] || '0');
                              const holidayHours = parseFloat(inputs[emp.id]?.[`${relationship.id}_holidayHours`] || '0');
                              const rate = relationship.payRate ? parseFloat(relationship.payRate) : (emp.payRate || 0);
                              const breakdown = [];
                              
                              if (hours > 0) breakdown.push(`${hours}hrs Ã— $${rate} = $${(hours * rate).toFixed(2)}`);
                              if (otHours > 0) breakdown.push(`${otHours}OT Ã— $${(rate * 1.5).toFixed(2)} = $${(otHours * rate * 1.5).toFixed(2)}`);
                              if (holidayHours > 0) breakdown.push(`${holidayHours}holiday Ã— $${(rate * 2).toFixed(2)} = $${(holidayHours * rate * 2).toFixed(2)}`);
                              
                              // Add Other Pay amounts
                              const otherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                              console.log(`ðŸ” [Breakdown Display] ${emp.name} - relationship ${relationship.id}:`, {
                                otherPayItems: otherPay,
                                selectedClientId,
                                empId: emp.id,
                                relationshipId: relationship.id
                              });
                              otherPay.forEach((item: OtherPayItem) => {
                                if (parseFloat(item.amount) > 0) {
                                  breakdown.push(`${item.description}: $${parseFloat(item.amount).toFixed(2)}`);
                                }
                              });
                              
                              return breakdown.length > 0 ? breakdown.map((item, index) => (
                                <div key={index} style={{ marginBottom: '2px' }}>
                                  {item}
                                </div>
                              )) : 'No hours entered';
                            }
                          }
                          
                          // Fallback to legacy fields
                          const hours = parseFloat(inputs[emp.id]?.hours || '0');
                          const otHours = parseFloat(inputs[emp.id]?.otHours || '0');
                          const holidayHours = parseFloat(inputs[emp.id]?.holidayHours || '0');
                          const rate = emp.payRate || 0;
                          const breakdown = [];
                          
                          if (hours > 0) breakdown.push(`${hours}hrs Ã— $${rate} = $${(hours * rate).toFixed(2)}`);
                          if (otHours > 0) breakdown.push(`${otHours}OT Ã— $${(rate * 1.5).toFixed(2)} = $${(otHours * rate * 1.5).toFixed(2)}`);
                          if (holidayHours > 0) breakdown.push(`${holidayHours}holiday Ã— $${(rate * 2).toFixed(2)} = $${(holidayHours * rate * 2).toFixed(2)}`);
                          
                          // Add Other Pay amounts for legacy employees
                          const otherPay = inputs[emp.id]?.otherPay || [];
                          otherPay.forEach((item: OtherPayItem) => {
                            if (parseFloat(item.amount) > 0) {
                              breakdown.push(`${item.description}: $${parseFloat(item.amount).toFixed(2)}`);
                            }
                          });
                          
                          return breakdown.length > 0 ? breakdown.map((item, index) => (
                            <div key={index} style={{ marginBottom: '2px' }}>
                              {item}
                            </div>
                          )) : 'No hours entered';
                        })()}
                      </Box>

                      {/* âœ… Hourly Total */}
                      
                    </Box>
                  )}
                  
                      {/* Per Diem Section - Show on per diem clients */}
                      {(() => {
                        console.log('ðŸ” [Legacy Per Diem Check]', {
                          empName: emp.name,
                          selectedClientId,
                          payTypes: emp.payTypes,
                          includesPerdiem: emp.payTypes?.includes('perdiem'),
                          willShowPerDiem: selectedClientId && emp.payTypes?.includes('perdiem')
                        });
                        return null;
                      })()}
                      {selectedClientId && emp.payTypes?.includes('perdiem') && (
                    <Box sx={{ 
                      p: 1.5, 
                      mb: 1.5, 
                      backgroundColor: '#fff3e0', 
                      borderRadius: 1, 
                      border: '1px solid #ffcc80',
                      width: '100%'
                    }}>
                      <Typography variant="subtitle2" fontWeight="bold" sx={{ mb: 0.5, color: '#f57c00' }}>
                        Per Diem Payment
                      </Typography>
                      
                      {/* Per Diem Type Selection */}
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 1 }}>
                        <Typography variant="body2" color="#f57c00">
                          Payment Type:
                        </Typography>
                        <Box sx={{ display: 'flex', gap: 1 }}>
                          <Button
                            size="small"
                            variant={(() => {
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? "outlined" : "contained";
                                }
                              }
                              return inputs[emp.id]?.perdiemBreakdown ? "outlined" : "contained";
                            })()}
                            onClick={() => {
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, false);
                                  return;
                                }
                              }
                              handleInputChange(emp.id, "perdiemBreakdown", false);
                            }}
                            sx={{ 
                              backgroundColor: (() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? 'transparent' : '#f57c00';
                                  }
                                }
                                return inputs[emp.id]?.perdiemBreakdown ? 'transparent' : '#f57c00';
                              })(),
                              color: (() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? '#f57c00' : 'white';
                                  }
                                }
                                return inputs[emp.id]?.perdiemBreakdown ? '#f57c00' : 'white';
                              })(),
                              borderColor: '#f57c00',
                              '&:hover': {
                                backgroundColor: (() => {
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? 'transparent' : '#e65100';
                                    }
                                  }
                                  return inputs[emp.id]?.perdiemBreakdown ? 'transparent' : '#e65100';
                                })(),
                              }
                            }}
                          >
                            Full Amount
                          </Button>
                          <Button
                            size="small"
                            variant={(() => {
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? "contained" : "outlined";
                                }
                              }
                              return inputs[emp.id]?.perdiemBreakdown ? "contained" : "outlined";
                            })()}
                            onClick={() => {
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                  return;
                                }
                              }
                              handleInputChange(emp.id, "perdiemBreakdown", true);
                            }}
                            sx={{ 
                              backgroundColor: (() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? '#f57c00' : 'transparent';
                                  }
                                }
                                return inputs[emp.id]?.perdiemBreakdown ? '#f57c00' : 'transparent';
                              })(),
                              color: (() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? 'white' : '#f57c00';
                                  }
                                }
                                return inputs[emp.id]?.perdiemBreakdown ? 'white' : '#f57c00';
                              })(),
                              borderColor: '#f57c00',
                              '&:hover': {
                                backgroundColor: (() => {
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] ? '#e65100' : 'transparent';
                                    }
                                  }
                                  return inputs[emp.id]?.perdiemBreakdown ? '#e65100' : 'transparent';
                                })(),
                              }
                            }}
                          >
                            Breakdown
                          </Button>
                        </Box>
                      </Box>

                      {/* Full Amount Input */}
                      {!(() => {
                        if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                          const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                          if (relationship) {
                            return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`];
                          }
                        }
                        return inputs[emp.id]?.perdiemBreakdown;
                      })() && (
                  <TextField
                          label="Amount"
                          type="number"
                          value={(() => {
                            // If employee has relationships and we're on a single client tab, use relationship-specific field
                            if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                              const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                              if (relationship) {
                                return inputs[emp.id]?.[`${relationship.id}_perdiemAmount`] || "";
                              }
                            }
                            // Fallback to legacy field
                            return inputs[emp.id]?.perdiemAmount || "";
                          })()}
                          onChange={(e) => {
                            // If employee has relationships and we're on a single client tab, update relationship-specific field
                            if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                              const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                              if (relationship) {
                                handleInputChange(emp.id, `${relationship.id}_perdiemAmount`, e.target.value);
                                return;
                              }
                            }
                            // Fallback to legacy field
                            handleInputChange(emp.id, "perdiemAmount", e.target.value);
                          }}
                          sx={{ width: 250 }}
                          placeholder="Enter amount"
                          size="small"
                        />
                      )}

                      {/* Daily Breakdown */}
                      {(() => {
                        if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                          const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                          if (relationship) {
                            return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`];
                          }
                        }
                        return inputs[emp.id]?.perdiemBreakdown;
                      })() && (
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
                          <Typography variant="body2" fontWeight="bold" color="#f57c00" sx={{ mb: 0.5 }}>
                            Daily Breakdown:
                          </Typography>
                          <Box sx={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))', gap: 1 }}>
                            <TextField
                              label="Monday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemMonday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemMonday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemMonday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemMonday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                            <TextField
                              label="Tuesday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemTuesday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemTuesday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemTuesday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemTuesday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                            <TextField
                              label="Wednesday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemWednesday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemWednesday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemWednesday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemWednesday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                            <TextField
                              label="Thursday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemThursday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemThursday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemThursday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemThursday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                            <TextField
                              label="Friday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemFriday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemFriday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemFriday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemFriday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                            <TextField
                              label="Saturday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemSaturday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemSaturday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemSaturday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemSaturday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                            <TextField
                              label="Sunday"
                              type="number"
                              value={(() => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return inputs[emp.id]?.[`${relationship.id}_perdiemSunday`] || "";
                                  }
                                }
                                return inputs[emp.id]?.perdiemSunday || "";
                              })()}
                              onChange={(e) => {
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    handleInputChange(emp.id, `${relationship.id}_perdiemSunday`, e.target.value);
                                    handleInputChange(emp.id, `${relationship.id}_perdiemBreakdown`, true);
                                    return;
                                  }
                                }
                                handleInputChange(emp.id, "perdiemSunday", e.target.value);
                                handleInputChange(emp.id, "perdiemBreakdown", true);
                              }}
                              size="small"
                              placeholder="0"
                            />
                          </Box>
                        </Box>
                      )}

                      {/* Calculation Breakdown - Above Total */}
                      <Box sx={{ 
                        mb: 0.5, 
                        p: 0.75, 
                        backgroundColor: '#fff8e1',
                        borderRadius: 1,
                        fontSize: '0.7rem',
                        textAlign: 'center',
                        color: '#f57c00'
                      }}>
                        {(() => {
                          // If employee has relationships and we're on a single client tab, use relationship-specific data
                          if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                            const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                            if (relationship) {
                              const perdiemBreakdown = inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`];
                              if (perdiemBreakdown) {
                                // Daily breakdown mode - calculate from relationship-specific daily fields
                                const dailyTotal = ['perdiemMonday', 'perdiemTuesday', 'perdiemWednesday', 
                                                   'perdiemThursday', 'perdiemFriday', 'perdiemSaturday', 'perdiemSunday']
                                  .reduce((sum, day) => sum + parseFloat(inputs[emp.id]?.[`${relationship.id}_${day}`] || '0'), 0);
                                return dailyTotal > 0 ? `$${dailyTotal.toFixed(2)} (daily breakdown)` : 'No daily amounts entered';
                              } else {
                                // Full amount mode - use relationship-specific amount
                                const amount = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemAmount`] || '0');
                                return amount > 0 ? `$${amount.toFixed(2)}` : 'No amount entered';
                              }
                            }
                          }
                          
                          // Fallback to legacy fields
                          if (inputs[emp.id]?.perdiemBreakdown) {
                            // Daily breakdown mode - just show total
                            const total = parseFloat(calculatePerDiemTotal(inputs[emp.id] || {}));
                            return total > 0 ? `$${total.toFixed(2)} (daily breakdown)` : 'No daily amounts entered';
                          } else {
                            // Full amount mode
                            const amount = parseFloat(inputs[emp.id]?.perdiemAmount || '0');
                            return amount > 0 ? `$${amount.toFixed(2)}` : 'No amount entered';
                          }
                        })()}
                      </Box>

                      {/* âœ… Per Diem Total */}
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5, p: 0.75, backgroundColor: '#fff8e1', borderRadius: 1 }}>
                        <Typography variant="body2" fontWeight="bold" color="#f57c00">
                          Per Diem Total:
                        </Typography>
                        <Typography variant="body2" fontWeight="bold" color="#f57c00">
                          ${(() => {
                            // If employee has relationships and we're on a single client tab, use relationship-specific calculation
                            if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                              const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                              if (relationship) {
                                // For single client with relationship, calculate from relationship-specific fields
                                const perdiemBreakdown = inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`];
                                
                                // Debug logging
                                console.log(`ðŸ” DEBUG per diem total calculation for ${emp.name}:`, {
                                  relationshipId: relationship.id,
                                  perdiemBreakdown,
                                  monday: inputs[emp.id]?.[`${relationship.id}_perdiemMonday`],
                                  tuesday: inputs[emp.id]?.[`${relationship.id}_perdiemTuesday`],
                                  wednesday: inputs[emp.id]?.[`${relationship.id}_perdiemWednesday`],
                                  thursday: inputs[emp.id]?.[`${relationship.id}_perdiemThursday`],
                                  friday: inputs[emp.id]?.[`${relationship.id}_perdiemFriday`],
                                  saturday: inputs[emp.id]?.[`${relationship.id}_perdiemSaturday`],
                                  sunday: inputs[emp.id]?.[`${relationship.id}_perdiemSunday`]
                                });
                                
                                if (perdiemBreakdown) {
                                  // Calculate from daily breakdown
                                  const monday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemMonday`] || '0') || 0;
                                  const tuesday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemTuesday`] || '0') || 0;
                                  const wednesday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemWednesday`] || '0') || 0;
                                  const thursday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemThursday`] || '0') || 0;
                                  const friday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemFriday`] || '0') || 0;
                                  const saturday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemSaturday`] || '0') || 0;
                                  const sunday = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemSunday`] || '0') || 0;
                                  
                                  const total = monday + tuesday + wednesday + thursday + friday + saturday + sunday;
                                  console.log(`ðŸ” DEBUG calculated total: ${total}`);
                                  return total > 0 ? total.toFixed(2) : '0.00';
                                } else {
                                  // Use full amount
                                  const amount = parseFloat(inputs[emp.id]?.[`${relationship.id}_perdiemAmount`] || '0') || 0;
                                  console.log(`ðŸ” DEBUG using full amount: ${amount}`);
                                  return amount > 0 ? amount.toFixed(2) : '0.00';
                                }
                              }
                            }
                            // Fallback to legacy calculation
                            return calculatePerDiemTotal(inputs[emp.id] || {});
                          })()}
                        </Typography>
                      </Box>
                      
                      {/* Other Pay Section for Per Diem */}
                      <Box sx={{ mt: 1, mb: 1 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                          <Typography variant="subtitle2" fontWeight="bold" sx={{ color: '#f57c00' }}>
                            Other Pay
                          </Typography>
                          <Button
                            size="small"
                            variant="outlined"
                            startIcon={<AddIcon />}
                            onClick={() => {
                              // Check if employee has relationships and we're on a single client tab
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  // Use relationship-specific field
                                  const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                  const newOtherPayItem = {
                                    id: Date.now().toString(),
                                    description: '',
                                    amount: ''
                                  };
                                  handleInputChange(emp.id, `${relationship.id}_otherPay`, [...currentOtherPay, newOtherPayItem]);
                                  return;
                                }
                              }
                              // Fallback to legacy field
                              const currentOtherPay = inputs[emp.id]?.otherPay || [];
                              const newOtherPayItem = {
                                id: Date.now().toString(),
                                description: '',
                                amount: ''
                              };
                              handleInputChange(emp.id, "otherPay", [...currentOtherPay, newOtherPayItem]);
                            }}
                            sx={{ fontSize: '0.7rem', py: 0.5 }}
                          >
                            Add Other Pay
                          </Button>
                        </Box>
                        
                        {(() => {
                          // Check if employee has relationships and we're on a single client tab
                          if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                            const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                            if (relationship) {
                              // Use relationship-specific field
                              return ((inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || []).map((item: OtherPayItem, index: number) => (
                                <Box key={item.id} sx={{ display: 'flex', gap: 1, mb: 1, alignItems: 'center' }}>
                                  <TextField
                                    label="Description"
                                    value={item.description}
                                    onChange={(e) => {
                                      const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                      const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                        payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                      );
                                      handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                    }}
                                    sx={{ flex: 2 }}
                                    size="small"
                                  />
                                  <TextField
                                    label="Amount"
                                    type="number"
                                    value={item.amount}
                                    onChange={(e) => {
                                      const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                      const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                        payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                      );
                                      handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                    }}
                                    sx={{ width: 100 }}
                                    size="small"
                                  />
                                  <IconButton
                                    size="small"
                                    color="error"
                                    onClick={() => {
                                      const currentOtherPay = (inputs[emp.id] as any)?.[`${relationship.id}_otherPay`] || [];
                                      const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                      handleInputChange(emp.id, `${relationship.id}_otherPay`, updatedOtherPay);
                                    }}
                                  >
                                    <DeleteIcon />
                                  </IconButton>
                                </Box>
                              ));
                            }
                          }
                          // Fallback to legacy field
                          return (inputs[emp.id]?.otherPay || []).map((item: OtherPayItem, index: number) => (
                            <Box key={item.id} sx={{ display: 'flex', gap: 1, mb: 1, alignItems: 'center' }}>
                              <TextField
                                label="Description"
                                value={item.description}
                                onChange={(e) => {
                                  const currentOtherPay = inputs[emp.id]?.otherPay || [];
                                  const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                    payItem.id === item.id ? { ...payItem, description: e.target.value } : payItem
                                  );
                                  handleInputChange(emp.id, "otherPay", updatedOtherPay);
                                }}
                                sx={{ flex: 2 }}
                                size="small"
                              />
                              <TextField
                                label="Amount"
                                type="number"
                                value={item.amount}
                                onChange={(e) => {
                                  const currentOtherPay = inputs[emp.id]?.otherPay || [];
                                  const updatedOtherPay = currentOtherPay.map((payItem: OtherPayItem) =>
                                    payItem.id === item.id ? { ...payItem, amount: e.target.value } : payItem
                                  );
                                  handleInputChange(emp.id, "otherPay", updatedOtherPay);
                                }}
                                sx={{ width: 100 }}
                                size="small"
                              />
                              <IconButton
                                size="small"
                                color="error"
                                onClick={() => {
                                  const currentOtherPay = inputs[emp.id]?.otherPay || [];
                                  const updatedOtherPay = currentOtherPay.filter((payItem: OtherPayItem) => payItem.id !== item.id);
                                  handleInputChange(emp.id, "otherPay", updatedOtherPay);
                                }}
                              >
                                <DeleteIcon />
                              </IconButton>
                            </Box>
                          ));
                        })()}
                      </Box>
                    </Box>
                      )}
                    </>
                  )}
                  <TextField
                    label=""
                    type="date"
                    value={(() => {
                      const checkDate = inputs[emp.id]?.checkDate;
                      if (!checkDate) return '';
                      return `${checkDate.getFullYear()}-${String(checkDate.getMonth() + 1).padStart(2, '0')}-${String(checkDate.getDate()).padStart(2, '0')}`;
                    })()}
                    onChange={(e) => {
                      if (e.target.value) {
                        // Use utility function to create date in local timezone
                        const dateValue = createLocalDate(e.target.value);
                        handleInputChange(emp.id, "checkDate", dateValue);
                      } else {
                        handleInputChange(emp.id, "checkDate", null);
                      }
                    }}
                    sx={{ flex: 1, minWidth: 200 }}
                    InputLabelProps={{
                      shrink: true,
                    }}
                    placeholder="Select check date"
                  />
                  <TextField
                    label="Memo (optional) - will show in middle section"
                    value={inputs[emp.id]?.memo || ""}
                    onChange={(e) =>
                      handleInputChange(emp.id, "memo", e.target.value)
                    }
                    sx={{ flex: 1, minWidth: 200 }}
                    placeholder="Enter memo (optional)"
                  />
                  <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <Typography variant="body2" color="text.secondary">
                      Amount: $
                    </Typography>
                    <Typography variant="h6" color="primary">
                      {calculateAmount(emp, inputs[emp.id] || { hours: "", otHours: "", holidayHours: "", memo: "", otherPay: [] })}
                    </Typography>
                  </Box>
                  
                  {/* Calculation Breakdown - Show based on client tab and actual data */}
                  {(() => {
                    // Show calculation breakdown if:
                    // 1. Multiple Clients tab (show for any data)
                    // 2. Americold Hourly tab (show for hourly data)
                    // 3. Americold Per Diem tab (show for per diem data)
                    const hasHourlyData = parseFloat(inputs[emp.id]?.hours || '0') > 0 || 
                                        parseFloat(inputs[emp.id]?.otHours || '0') > 0 || 
                                        parseFloat(inputs[emp.id]?.holidayHours || '0') > 0;
                    const hasPerDiemData = (() => {
                      // If employee has relationships and we're on a single client tab, use relationship-specific calculation
                      if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                        const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                        if (relationship) {
                          return parseFloat(calculatePerDiemTotalForRelationship(inputs[emp.id] || {}, relationship.id)) > 0;
                        }
                      }
                      // Fallback to legacy calculation
                      return parseFloat(calculatePerDiemTotal(inputs[emp.id] || {})) > 0;
                    })();
                    
                    if (selectedClientId === 'multiple') {
                      // Multiple clients: show for any data
                      return (hasHourlyData || hasPerDiemData) && selectedEmployees[emp.id];
                    } else if (selectedClientId && companyClients.find(c => c.id === selectedClientId)?.name.toLowerCase().includes('hourly')) {
                      // Hourly client: show for hourly data only
                      return hasHourlyData && selectedEmployees[emp.id];
                    } else if (selectedClientId && companyClients.find(c => c.id === selectedClientId)?.name.toLowerCase().includes('per diem')) {
                      // Per diem client: show for per diem data only
                      return hasPerDiemData && selectedEmployees[emp.id];
                    }
                    return false;
                  })() && (
                    <Box sx={{ 
                      mt: 1, 
                      p: 2, 
                      backgroundColor: '#f8f9fa', 
                      borderRadius: 1, 
                      border: '1px solid #e9ecef',
                      width: '100%'
                    }}>
                      <Typography variant="caption" fontWeight="bold" sx={{ mb: 1, color: '#495057', display: 'block' }}>
                        ðŸ’° Calculation Breakdown:
                      </Typography>
                      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5, fontSize: '0.75rem' }}>
                        {/* Hourly data - only show on hourly or multiple clients tabs */}
                        {(selectedClientId === 'multiple' || 
                          (selectedClientId && companyClients.find(c => c.id === selectedClientId)?.name.toLowerCase().includes('hourly'))) && (
                          <>
                            {parseFloat(inputs[emp.id]?.hours || '0') > 0 && (
                              <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                <span>Regular Hours ({inputs[emp.id]?.hours || '0'}h Ã— ${getEffectivePayRate(emp, inputs[emp.id] || {}, 'hourly').toFixed(2)}):</span>
                                <span>${(parseFloat(inputs[emp.id]?.hours || '0') * getEffectivePayRate(emp, inputs[emp.id] || {}, 'hourly')).toFixed(2)}</span>
                              </Box>
                            )}
                            {parseFloat(inputs[emp.id]?.otHours || '0') > 0 && (
                              <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                <span>OT Hours ({inputs[emp.id]?.otHours || '0'}h Ã— ${(getEffectivePayRate(emp, inputs[emp.id] || {}, 'hourly') * 1.5).toFixed(2)}):</span>
                                <span>${(parseFloat(inputs[emp.id]?.otHours || '0') * getEffectivePayRate(emp, inputs[emp.id] || {}, 'hourly') * 1.5).toFixed(2)}</span>
                              </Box>
                            )}
                            {parseFloat(inputs[emp.id]?.holidayHours || '0') > 0 && (
                              <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                <span>Holiday Hours ({inputs[emp.id]?.holidayHours || '0'}h Ã— ${(getEffectivePayRate(emp, inputs[emp.id] || {}, 'hourly') * 2).toFixed(2)}):</span>
                                <span>${(parseFloat(inputs[emp.id]?.holidayHours || '0') * getEffectivePayRate(emp, inputs[emp.id] || {}, 'hourly') * 2).toFixed(2)}</span>
                              </Box>
                            )}
                            {/* Other Pay items */}
                            {(inputs[emp.id]?.otherPay || []).map((item: OtherPayItem, index: number) => (
                              parseFloat(item.amount) > 0 && (
                                <Box key={item.id} sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                  <span>{item.description}:</span>
                                  <span>${parseFloat(item.amount).toFixed(2)}</span>
                                </Box>
                              )
                            ))}
                          </>
                        )}
                        {/* Per diem data - only show on per diem or multiple clients tabs */}
                        {(selectedClientId === 'multiple' || 
                          (selectedClientId && companyClients.find(c => c.id === selectedClientId)?.name.toLowerCase().includes('per diem'))) && (
                          <>
                            {(() => {
                              // If employee has relationships and we're on a single client tab, use relationship-specific calculation
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  const total = parseFloat(calculatePerDiemTotalForRelationship(inputs[emp.id] || {}, relationship.id));
                                  return total > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                      <span>Per Diem Amount:</span>
                                      <span>${total.toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                }
                              }
                              // Fallback to legacy calculation
                              const total = parseFloat(calculatePerDiemTotal(inputs[emp.id] || {}));
                              return total > 0 ? (
                                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                  <span>Per Diem Amount:</span>
                                  <span>${total.toFixed(2)}</span>
                                </Box>
                              ) : null;
                            })()}
                            {/* âœ… Show daily breakdown if using breakdown mode */}
                            {(() => {
                              // If employee has relationships and we're on a single client tab, use relationship-specific fields
                              if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                if (relationship) {
                                  return inputs[emp.id]?.[`${relationship.id}_perdiemBreakdown`] && 
                                         parseFloat(calculatePerDiemTotalForRelationship(inputs[emp.id] || {}, relationship.id)) > 0;
                                }
                              }
                              // Fallback to legacy fields
                              return inputs[emp.id]?.perdiemBreakdown && 
                                     parseFloat(calculatePerDiemTotal(inputs[emp.id] || {})) > 0;
                            })() && (
                              <Box sx={{ ml: 2, mt: 0.5 }}>
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const monday = inputs[emp.id]?.[`${relationship.id}_perdiemMonday`];
                                      return monday && parseFloat(monday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Monday:</span>
                                          <span>${parseFloat(monday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const monday = inputs[emp.id]?.perdiemMonday;
                                  return monday && parseFloat(monday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Monday:</span>
                                      <span>${parseFloat(monday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const tuesday = inputs[emp.id]?.[`${relationship.id}_perdiemTuesday`];
                                      return tuesday && parseFloat(tuesday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Tuesday:</span>
                                          <span>${parseFloat(tuesday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const tuesday = inputs[emp.id]?.perdiemTuesday;
                                  return tuesday && parseFloat(tuesday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Tuesday:</span>
                                      <span>${parseFloat(tuesday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const wednesday = inputs[emp.id]?.[`${relationship.id}_perdiemWednesday`];
                                      return wednesday && parseFloat(wednesday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Wednesday:</span>
                                          <span>${parseFloat(wednesday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const wednesday = inputs[emp.id]?.perdiemWednesday;
                                  return wednesday && parseFloat(wednesday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Wednesday:</span>
                                      <span>${parseFloat(wednesday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const thursday = inputs[emp.id]?.[`${relationship.id}_perdiemThursday`];
                                      return thursday && parseFloat(thursday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Thursday:</span>
                                          <span>${parseFloat(thursday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const thursday = inputs[emp.id]?.perdiemThursday;
                                  return thursday && parseFloat(thursday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Thursday:</span>
                                      <span>${parseFloat(thursday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const friday = inputs[emp.id]?.[`${relationship.id}_perdiemFriday`];
                                      return friday && parseFloat(friday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Friday:</span>
                                          <span>${parseFloat(friday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const friday = inputs[emp.id]?.perdiemFriday;
                                  return friday && parseFloat(friday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Friday:</span>
                                      <span>${parseFloat(friday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const saturday = inputs[emp.id]?.[`${relationship.id}_perdiemSaturday`];
                                      return saturday && parseFloat(saturday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Saturday:</span>
                                          <span>${parseFloat(saturday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const saturday = inputs[emp.id]?.perdiemSaturday;
                                  return saturday && parseFloat(saturday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Saturday:</span>
                                      <span>${parseFloat(saturday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                                {(() => {
                                  // If employee has relationships and we're on a single client tab, use relationship-specific fields
                                  if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                    const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                    if (relationship) {
                                      const sunday = inputs[emp.id]?.[`${relationship.id}_perdiemSunday`];
                                      return sunday && parseFloat(sunday) > 0 ? (
                                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                          <span>â€¢ Sunday:</span>
                                          <span>${parseFloat(sunday).toFixed(2)}</span>
                                        </Box>
                                      ) : null;
                                    }
                                  }
                                  // Fallback to legacy fields
                                  const sunday = inputs[emp.id]?.perdiemSunday;
                                  return sunday && parseFloat(sunday) > 0 ? (
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', color: '#666' }}>
                                      <span>â€¢ Sunday:</span>
                                      <span>${parseFloat(sunday).toFixed(2)}</span>
                                    </Box>
                                  ) : null;
                                })()}
                              </Box>
                            )}
                          </>
                        )}
                        <Divider sx={{ my: 0.5 }} />
                        {/* âœ… Show individual totals if both payment methods are used (only on multiple clients tab) */}
                        {selectedClientId === 'multiple' && 
                         parseFloat(inputs[emp.id]?.hours || '0') > 0 && 
                         parseFloat(calculatePerDiemTotal(inputs[emp.id] || {})) > 0 && (
                          <>
                            
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', fontWeight: 'bold', color: '#f57c00' }}>
                              <span>Per Diem Total:</span>
                              <span>${(() => {
                                // If employee has relationships and we're on a single client tab, use relationship-specific calculation
                                if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
                                  const relationship = emp.clientPayTypeRelationships.find(rel => rel.clientId === selectedClientId);
                                  if (relationship) {
                                    return calculatePerDiemTotalForRelationship(inputs[emp.id] || {}, relationship.id);
                                  }
                                }
                                // Fallback to legacy calculation
                                return calculatePerDiemTotal(inputs[emp.id] || {});
                              })()}</span>
                            </Box>
                            <Divider sx={{ my: 0.5 }} />
                          </>
                        )}
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', fontWeight: 'bold', color: '#1976d2' }}>
                          <span>Total Amount:</span>
                          <span>${calculateAmount(emp, inputs[emp.id] || {})}</span>
                        </Box>
{/* Review Checks Button */}
{(() => {
 const employeesWithData = employeesToShow.filter((emp: any) => {
  const data = inputs[emp.id];
  if (!data) return false;
  
  // Check legacy fields
  const hasLegacyHours = data.hours && parseFloat(data.hours) > 0;
  const hasLegacyPerDiem = data.perdiemAmount && parseFloat(data.perdiemAmount) > 0;
  const hasLegacyBreakdown = data.perdiemBreakdown && Object.values(data.perdiemBreakdown).some(val => parseFloat(val as string) > 0);
  
  // Check relationship-specific fields
   // Check relationship-specific fields
   let hasRelationshipData = false;
  
   // Check for single client relationships
   if (emp.clientPayTypeRelationships && selectedClientId !== 'multiple') {
     const relationship = emp.clientPayTypeRelationships.find((rel: any) => rel.clientId === selectedClientId);
     if (relationship) {
       const relId = relationship.id;
       const hasRelHours = data[`${relId}_hours`] && parseFloat(data[`${relId}_hours`]) > 0;
       const hasRelOTHours = data[`${relId}_otHours`] && parseFloat(data[`${relId}_otHours`]) > 0;
       const hasRelHolidayHours = data[`${relId}_holidayHours`] && parseFloat(data[`${relId}_holidayHours`]) > 0;
       const hasRelPerDiemAmount = data[`${relId}_perdiemAmount`] && parseFloat(data[`${relId}_perdiemAmount`]) > 0;
       
       // Check Other Pay fields
       const hasRelOtherPay = data[`${relId}_otherPay`] && Array.isArray(data[`${relId}_otherPay`]) && 
         data[`${relId}_otherPay`].some((item: OtherPayItem) => parseFloat(item.amount) > 0);
       
       // Check daily breakdown fields
       const dailyFields = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
       const hasRelDailyBreakdown = dailyFields.some(day => 
         data[`${relId}_perdiem${day}`] && parseFloat(data[`${relId}_perdiem${day}`]) > 0
       );
       
       hasRelationshipData = hasRelHours || hasRelOTHours || hasRelHolidayHours || hasRelPerDiemAmount || hasRelDailyBreakdown || hasRelOtherPay;
     }
   }
   
   // Check for multiple client relationships
   if (emp.clientPayTypeRelationships && selectedClientId === 'multiple') {
     // Check all selected relationships for multiple clients
     const selectedRelationshipIds = data.selectedRelationshipIds || [];
     selectedRelationshipIds.forEach((relId: string) => {
       const hasRelHours = data[`${relId}_hours`] && parseFloat(data[`${relId}_hours`]) > 0;
       const hasRelOTHours = data[`${relId}_otHours`] && parseFloat(data[`${relId}_otHours`]) > 0;
       const hasRelHolidayHours = data[`${relId}_holidayHours`] && parseFloat(data[`${relId}_holidayHours`]) > 0;
       const hasRelPerDiemAmount = data[`${relId}_perdiemAmount`] && parseFloat(data[`${relId}_perdiemAmount`]) > 0;
       
       // Check daily breakdown fields
       const dailyFields = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
       const hasRelDailyBreakdown = dailyFields.some(day => 
         data[`${relId}_perdiem${day}`] && parseFloat(data[`${relId}_perdiem${day}`]) > 0
       );
       
       if (hasRelHours || hasRelOTHours || hasRelHolidayHours || hasRelPerDiemAmount || hasRelDailyBreakdown) {
         hasRelationshipData = true;
       }
     });
   }
  
  return hasLegacyHours || hasLegacyPerDiem || hasLegacyBreakdown || hasRelationshipData;
});
  
return employeesWithData.length > 0 && (
  <Box sx={{ mt: 3, textAlign: 'center', display: 'flex', gap: 2, justifyContent: 'center', flexWrap: 'wrap' }}>
    
    
    {/* Review Checks Button */}
    <Button
      variant="contained"
      size="large"
      onClick={reviewChecks}
      disabled={isCreatingChecks}
      sx={{ 
        px: 4,
        py: 1.5,
        fontSize: '1.1rem',
        fontWeight: 'bold',
        borderRadius: 2,
        boxShadow: 3,
        '&:hover': {
          boxShadow: 6,
          transform: 'translateY(-2px)',
        },
        transition: 'all 0.2s ease-in-out',
      }}
    >
      {isCreatingChecks ? "Creating Checks..." : " Review Checks Before Creating"}
    </Button>
  </Box>
);
})()}
</>
);

          
             })()} {/* This is the closing of the main employee filtering IIFE at line 3448 */}
          

          
        </>
      )}

      <Snackbar
        open={showSuccessMessage}
        autoHideDuration={2000}
        onClose={() => setShowSuccessMessage(false)}
      >
        <Alert onClose={() => setShowSuccessMessage(false)} severity="success">
          âœ… Checks created successfully!
        </Alert>
      </Snackbar>

      {/* Floating Review Panel */}
      {showReviewPanel && (
        <Box
          sx={{
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '95vw',
            maxWidth: '1400px',
            maxHeight: '90vh',
            bgcolor: 'background.paper',
            borderRadius: 2,
            boxShadow: 24,
            p: 3,
            zIndex: 1300,
            overflow: 'auto',
            '@media print': {
              position: 'static',
              transform: 'none',
              width: '100%',
              maxWidth: '100%',
              maxHeight: 'none',
              boxShadow: 'none',
              borderRadius: 0,
              p: 2,
              overflow: 'visible'
            }
          }}
        >
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h5" fontWeight="bold">
              Review Checks Before Creating
            </Typography>
            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
              <Button
                variant="outlined"
                startIcon={<PrintIcon />}
                onClick={generateReviewPDF}
                sx={{ 
                  minWidth: 'auto'
                }}
              >
                Print PDF
              </Button>
              <Button
                onClick={() => {
                  setShowReviewPanel(false);
                  setSelectedClientTab(null);
                }}
                sx={{ 
                  minWidth: 'auto',
                  '@media print': {
                    display: 'none'
                  }
                }}
              >
                âœ•
              </Button>
            </Box>
          </Box>

          <Typography 
            variant="body2" 
            color="text.secondary" 
            sx={{ 
              mb: 3,
              '@media print': {
                display: 'none'
              }
            }}
          >
            Please review the following checks before creating them. You can go back to make changes if needed.
          </Typography>
          
          {/* Print Header - Only visible when printing */}
          <Box
            sx={{
              display: 'none',
              '@media print': {
                display: 'block',
                mb: 2,
                pb: 2,
                borderBottom: '2px solid #000'
              }
            }}
          >
            <Typography variant="h6" fontWeight="bold" sx={{ mb: 1 }}>
              Payroll Checks Review
            </Typography>
            <Typography variant="body2">
              Generated: {new Date().toLocaleString()}
            </Typography>
            <Typography variant="body2" sx={{ mt: 1 }}>
              Company: {companies.find(c => c.id === selectedCompanyId)?.name || 'N/A'}
            </Typography>
          </Box>

          {(() => {
            // Get all unique clients/departments from all employees (using clientId as unique key)
            const allClientsMap = new Map<string, { clientId: string; clientName: string; division?: string }>();
            reviewData.forEach(item => {
              if (item.clientBreakdown) {
                item.clientBreakdown.forEach(breakdown => {
                  // Use clientId as unique key
                  const uniqueKey = breakdown.clientId;
                  if (!allClientsMap.has(uniqueKey)) {
                    allClientsMap.set(uniqueKey, {
                      clientId: breakdown.clientId,
                      clientName: breakdown.clientName,
                      division: breakdown.division
                    });
                  }
                });
              }
            });
            const clientList = Array.from(allClientsMap.keys()).sort();

            // Use selected client tab or default to first client
            const currentSelectedTab = selectedClientTab || (clientList.length > 0 ? clientList[0] : null);

            // Calculate totals per client (using clientId)
            const clientTotals = clientList.map(uniqueKey => {
              const clientInfo = allClientsMap.get(uniqueKey)!;
              const total = reviewData.reduce((sum, item) => {
                const breakdown = item.clientBreakdown?.find(b => b.clientId === uniqueKey);
                return sum + (breakdown?.amount || 0);
              }, 0);
              // Create display name: "ClientName" or "ClientName (Division)" if division exists
              const displayName = clientInfo.division && clientInfo.division.trim()
                ? `${clientInfo.clientName} (${clientInfo.division})`
                : clientInfo.clientName;
              return { 
                uniqueKey,
                clientId: clientInfo.clientId,
                clientName: clientInfo.clientName,
                division: clientInfo.division,
                displayName,
                total 
              };
            });

            // Get employees for selected client (using clientId)
            const employeesForSelectedClient = currentSelectedTab
              ? reviewData.filter(item => {
                  return item.clientBreakdown?.some(b => b.clientId === currentSelectedTab);
                })
              : [];

            return (
              <Box>
                {/* Summary Table - Totals per Client */}
                <Paper sx={{ mb: 3, p: 2 }}>
                  <Typography variant="h6" fontWeight="bold" sx={{ mb: 2 }}>
                    Summary by Client/Department
                  </Typography>
                  <TableContainer>
                    <Table size="small">
                      <TableHead>
                        <TableRow sx={{ backgroundColor: '#f5f5f5' }}>
                          <TableCell sx={{ fontWeight: 'bold' }}>Client/Department</TableCell>
                          <TableCell align="right" sx={{ fontWeight: 'bold' }}>Total Amount</TableCell>
                          <TableCell align="center" sx={{ fontWeight: 'bold' }}>Employees</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {clientTotals.map(({ uniqueKey, displayName, total }) => {
                          const employeeCount = reviewData.filter(item => 
                            item.clientBreakdown?.some(b => b.clientId === uniqueKey)
                          ).length;
                          return (
                            <TableRow 
                              key={uniqueKey}
                              onClick={() => setSelectedClientTab(uniqueKey)}
                              sx={{ 
                                cursor: 'pointer',
                                '&:hover': { backgroundColor: currentSelectedTab === uniqueKey ? '#e3f2fd' : '#f5f5f5' },
                                backgroundColor: currentSelectedTab === uniqueKey ? '#e3f2fd' : 'white'
                              }}
                            >
                              <TableCell sx={{ fontWeight: 'bold' }}>
                                {displayName}
                              </TableCell>
                              <TableCell align="right" sx={{ fontWeight: 'bold', fontSize: '1.1rem' }}>
                                ${total.toFixed(2)}
                              </TableCell>
                              <TableCell align="center">
                                {employeeCount} {employeeCount === 1 ? 'employee' : 'employees'}
                              </TableCell>
                            </TableRow>
                          );
                        })}
                        <TableRow sx={{ backgroundColor: '#e3f2fd', fontWeight: 'bold' }}>
                          <TableCell sx={{ fontWeight: 'bold' }}>
                            <strong>GRAND TOTAL</strong>
                          </TableCell>
                          <TableCell align="right" sx={{ fontWeight: 'bold', fontSize: '1.2rem' }}>
                            <strong>${reviewData.reduce((sum, item) => sum + item.calculatedAmount, 0).toFixed(2)}</strong>
                          </TableCell>
                          <TableCell align="center" sx={{ fontWeight: 'bold' }}>
                            {reviewData.length} {reviewData.length === 1 ? 'employee' : 'employees'}
                          </TableCell>
                        </TableRow>
                      </TableBody>
                    </Table>
                  </TableContainer>
                </Paper>

                {/* Detailed Employee Breakdown for Selected Client */}
                {currentSelectedTab && employeesForSelectedClient.length > 0 && (
                  <Paper sx={{ p: 2 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6" fontWeight="bold">
                        Employee Breakdown: {(() => {
                          const selectedClientInfo = allClientsMap.get(currentSelectedTab);
                          return selectedClientInfo 
                            ? (selectedClientInfo.division && selectedClientInfo.division.trim()
                                ? `${selectedClientInfo.clientName} (${selectedClientInfo.division})`
                                : selectedClientInfo.clientName)
                            : currentSelectedTab;
                        })()}
                      </Typography>
                      <Box 
                        sx={{ 
                          display: 'flex', 
                          gap: 1, 
                          flexWrap: 'wrap',
                          '@media print': {
                            display: 'none'
                          }
                        }}
                      >
                        {clientTotals.map(({ uniqueKey, displayName, clientName }) => {
                          return (
                            <Button
                              key={uniqueKey}
                              variant={currentSelectedTab === uniqueKey ? "contained" : "outlined"}
                              size="small"
                              onClick={() => setSelectedClientTab(uniqueKey)}
                              sx={{
                                minWidth: 100,
                                backgroundColor: currentSelectedTab === uniqueKey 
                                  ? (clientName.toLowerCase().includes('fusion') ? '#1976d2' : 
                                     clientName.toLowerCase().includes('lto') ? '#4caf50' : '#f57c00')
                                  : 'transparent'
                              }}
                            >
                              {displayName}
                            </Button>
                          );
                        })}
                      </Box>
                    </Box>

                    <TableContainer>
                      <Table size="small">
                        <TableHead>
                          <TableRow sx={{ backgroundColor: '#f5f5f5' }}>
                            <TableCell sx={{ fontWeight: 'bold' }}>Employee</TableCell>
                            <TableCell align="right" sx={{ fontWeight: 'bold' }}>Pay Type</TableCell>
                            <TableCell align="right" sx={{ fontWeight: 'bold' }}>Details</TableCell>
                            <TableCell align="right" sx={{ fontWeight: 'bold' }}>Amount</TableCell>
                          </TableRow>
                        </TableHead>
                        <TableBody>
                          {employeesForSelectedClient.map((item, index) => {
                            const breakdown = item.clientBreakdown?.find(b => b.clientId === currentSelectedTab);
                            if (!breakdown) return null;

                            return (
                              <TableRow 
                                key={index}
                                sx={{ '&:nth-of-type(odd)': { backgroundColor: '#fafafa' } }}
                              >
                                <TableCell sx={{ fontWeight: 'bold' }}>
                                  {item.employee.name}
                                </TableCell>
                                <TableCell align="right">
                                  <Typography 
                                    variant="body2"
                                    sx={{ 
                                      color: breakdown.payType === 'Hourly' ? '#1976d2' : '#f57c00',
                                      fontWeight: 'bold'
                                    }}
                                  >
                                    {breakdown.payType}
                                  </Typography>
                                </TableCell>
                                <TableCell align="right">
                                  {breakdown.details && breakdown.details.length > 0 ? (
                                    <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: 0.5 }}>
                                      {breakdown.details.map((detail, idx) => (
                                        <Typography key={idx} variant="caption" sx={{ fontSize: '0.75rem', color: 'text.secondary' }}>
                                          {detail.label}: {detail.value}
                                        </Typography>
                                      ))}
                                    </Box>
                                  ) : (
                                    <Typography variant="body2" sx={{ color: 'text.disabled' }}>
                                      -
                                    </Typography>
                                  )}
                                </TableCell>
                                <TableCell align="right" sx={{ fontWeight: 'bold' }}>
                                  <Typography 
                                    variant="body1"
                                    sx={{ 
                                      color: breakdown.payType === 'Hourly' ? '#1976d2' : '#f57c00',
                                      fontWeight: 'bold'
                                    }}
                                  >
                                    ${breakdown.amount.toFixed(2)}
                                  </Typography>
                                </TableCell>
                              </TableRow>
                            );
                          })}
                          <TableRow sx={{ backgroundColor: '#e3f2fd', fontWeight: 'bold' }}>
                            <TableCell colSpan={3} sx={{ fontWeight: 'bold' }}>
                              <strong>Subtotal for {(() => {
                                const selectedClientInfo = allClientsMap.get(currentSelectedTab);
                                return selectedClientInfo 
                                  ? (selectedClientInfo.division && selectedClientInfo.division.trim()
                                      ? `${selectedClientInfo.clientName} (${selectedClientInfo.division})`
                                      : selectedClientInfo.clientName)
                                  : currentSelectedTab;
                              })()}</strong>
                            </TableCell>
                            <TableCell align="right" sx={{ fontWeight: 'bold', fontSize: '1.1rem' }}>
                              <strong>
                                ${employeesForSelectedClient.reduce((sum, item) => {
                                  const breakdown = item.clientBreakdown?.find(b => b.clientId === currentSelectedTab);
                                  return sum + (breakdown?.amount || 0);
                                }, 0).toFixed(2)}
                              </strong>
                            </TableCell>
                          </TableRow>
                        </TableBody>
                      </Table>
                    </TableContainer>
                  </Paper>
                )}
              </Box>
            );
          })()}

          {/* Action Buttons */}
          <Box 
            sx={{ 
              display: 'flex', 
              gap: 2, 
              justifyContent: 'center',
              flexWrap: 'wrap',
              '@media print': {
                display: 'none'
              }
            }}
          >
            <Button
              variant="outlined"
              onClick={() => {
                setShowReviewPanel(false);
                setSelectedClientTab(null);
              }}
              size="large"
            >
              â† Go Back & Edit
            </Button>
            <Button
              variant="outlined"
              color="primary"
              onClick={() => {
                // Close review panel but keep all data intact
                setShowReviewPanel(false);
                setSelectedClientTab(null);
                // Data remains in tabData and inputs, so user can continue editing
              }}
              size="large"
            >
              Continue Reviewing
            </Button>
            <Button
              variant="contained"
              onClick={() => {
                setShowReviewPanel(false);
                setSelectedClientTab(null);
                handleCreateChecks();
              }}
              disabled={isCreatingChecks}
              size="large"
              startIcon={<span></span>}
            >
              {isCreatingChecks ? "Creating Checks..." : "Create Checks"}
            </Button>
          </Box>
        </Box>
      )}
      
      {/* Floating Navigation Menu */}
      <Fade in={floatingMenu.open} timeout={500}>
        <Box
          sx={{
            position: 'fixed',
            top: 20,
            right: 20,
            zIndex: 9999,
          }}
        >
          <Paper
            elevation={8}
            sx={{
              p: 2,
              minWidth: 280,
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              color: 'white',
              borderRadius: 2,
            }}
          >
            <Typography variant="h6" sx={{ mb: 2, fontWeight: 'bold' }}>
              âœ… Check Created Successfully!
            </Typography>
            
            <Box sx={{ mb: 2 }}>
              <Typography variant="body2" sx={{ opacity: 0.9 }}>
                <strong>Company:</strong> {floatingMenu.companyName}
              </Typography>
              <Typography variant="body2" sx={{ opacity: 0.9 }}>
                <strong>Client:</strong> {floatingMenu.clientName}
              </Typography>
            </Box>
            
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              <Button
                variant="contained"
                size="small"
                fullWidth
                onClick={() => {
                  // Navigate to View Checks with company filter
                  onGoToSection('View Checks');
                  // Set a flag to indicate we want to filter by company
                  localStorage.setItem('pendingCompanyFilter', floatingMenu.companyId || '');
                  // Set a flag to indicate we want to filter by week
                  setFloatingMenu(prev => ({ ...prev, open: false }));
                }}
                sx={{
                  background: 'rgba(255,255,255,0.2)',
                  '&:hover': { background: 'rgba(255,255,255,0.3)' }
                }}
              >
                ðŸ“Š View My Checks
              </Button>
              
              {floatingMenu.clientId && (
                <Button
                  variant="contained"
                  size="small"
                  fullWidth
                  onClick={() => {
                    // Navigate to View Checks with company and client filter
                    onGoToSection('View Checks');
                    // Set flags to indicate we want to filter by company and client
                    localStorage.setItem('pendingCompanyFilter', floatingMenu.companyId || '');
                  // Set a flag to indicate we want to filter by week
                    localStorage.setItem('pendingClientFilter', floatingMenu.clientId || '');
                    setFloatingMenu(prev => ({ ...prev, open: false }));
                  }}
                  sx={{
                    background: 'rgba(255,255,255,0.2)',
                    '&:hover': { background: 'rgba(255,255,255,0.3)' }
                  }}
                >
                  ðŸ‘¥ View Client Checks
                </Button>
              )}
              
              <Button
                variant="outlined"
                size="small"
                fullWidth
                onClick={() => setFloatingMenu(prev => ({ ...prev, open: false }))}
                sx={{
                  borderColor: 'rgba(255,255,255,0.5)',
                  color: 'white',
                  '&:hover': { 
                    borderColor: 'white',
                    background: 'rgba(255,255,255,0.1)'
                  }
                }}
              >
                âœ• Close
              </Button>
            </Box>
          </Paper>
        </Box>
      </Fade>

   
    </Box>
  );
};

export default BatchChecks;

